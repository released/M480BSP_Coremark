; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -I..\Coremark -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DMAIN_HAS_NOARGC --omf_browse=.\obj\uart.crf ..\..\..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=2

                  UART_ClearIntFlag PROC
;;;39     
;;;40     void UART_ClearIntFlag(UART_T* uart, uint32_t u32InterruptFlag)
000000  f4116f80          TST      r1,#0x400
;;;41     {
000004  d003              BEQ      |L1.14|
;;;42     
;;;43         if(u32InterruptFlag & UART_INTSTS_RLSINT_Msk)   /* Clear Receive Line Status Interrupt */
;;;44         {
;;;45             uart->FIFOSTS = UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk;
000006  2270              MOVS     r2,#0x70
000008  6182              STR      r2,[r0,#0x18]
;;;46             uart->FIFOSTS = UART_FIFOSTS_ADDRDETF_Msk;
00000a  2208              MOVS     r2,#8
00000c  6182              STR      r2,[r0,#0x18]
                  |L1.14|
;;;47         }
;;;48     
;;;49         if(u32InterruptFlag & UART_INTSTS_MODEMINT_Msk)   /* Clear Modem Status Interrupt */
00000e  f4116f00          TST      r1,#0x800
000012  d003              BEQ      |L1.28|
;;;50         {
;;;51             uart->MODEMSTS |= UART_MODEMSTS_CTSDETF_Msk;
000014  6942              LDR      r2,[r0,#0x14]
000016  f0420201          ORR      r2,r2,#1
00001a  6142              STR      r2,[r0,#0x14]
                  |L1.28|
;;;52         }
;;;53         else
;;;54         {
;;;55         }
;;;56     
;;;57         if(u32InterruptFlag & UART_INTSTS_BUFERRINT_Msk)   /* Clear Buffer Error Interrupt */
00001c  f4115f00          TST      r1,#0x2000
;;;58         {
;;;59             uart->FIFOSTS = UART_FIFOSTS_RXOVIF_Msk | UART_FIFOSTS_TXOVIF_Msk;
000020  bf1c              ITT      NE
000022  4a08              LDRNE    r2,|L1.68|
000024  6182              STRNE    r2,[r0,#0x18]
;;;60         }
;;;61     
;;;62         if(u32InterruptFlag & UART_INTSTS_WKINT_Msk)   /* Clear Wake-up Interrupt */
000026  f4114f80          TST      r1,#0x4000
;;;63         {
;;;64             uart->WKSTS = UART_WKSTS_CTSWKF_Msk  | UART_WKSTS_DATWKF_Msk  |
00002a  bf1c              ITT      NE
00002c  221f              MOVNE    r2,#0x1f
00002e  6442              STRNE    r2,[r0,#0x44]
;;;65                           UART_WKSTS_RFRTWKF_Msk |UART_WKSTS_RS485WKF_Msk |
;;;66                           UART_WKSTS_TOUTWKF_Msk;
;;;67         }
;;;68     
;;;69         if(u32InterruptFlag & UART_INTSTS_LININT_Msk)   /* Clear LIN Bus Interrupt */
000030  f4114f00          TST      r1,#0x8000
;;;70         {
;;;71             uart->INTSTS = UART_INTSTS_LINIF_Msk;
;;;72             uart->LINSTS = UART_LINSTS_BITEF_Msk    | UART_LINSTS_BRKDETF_Msk  |
;;;73                            UART_LINSTS_SLVSYNCF_Msk | UART_LINSTS_SLVIDPEF_Msk |
;;;74                            UART_LINSTS_SLVHEF_Msk   | UART_LINSTS_SLVHDETF_Msk ;
;;;75         }
;;;76     }
000034  bf08              IT       EQ
000036  4770              BXEQ     lr
000038  2180              MOVS     r1,#0x80              ;71
00003a  61c1              STR      r1,[r0,#0x1c]         ;71
00003c  f240310f          MOV      r1,#0x30f             ;72
000040  6381              STR      r1,[r0,#0x38]         ;72
000042  4770              BX       lr
;;;77     
                          ENDP

                  |L1.68|
                          DCD      0x01000001

                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;87      */
;;;88     void UART_Close(UART_T* uart)
000000  2100              MOVS     r1,#0
;;;89     {
;;;90         uart->INTEN = 0ul;
000002  6041              STR      r1,[r0,#4]
;;;91     }
000004  4770              BX       lr
;;;92     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;102     */
;;;103    void UART_DisableFlowCtrl(UART_T* uart)
000000  6841              LDR      r1,[r0,#4]
;;;104    {
;;;105        uart->INTEN &= ~(UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk);
000002  f4215140          BIC      r1,r1,#0x3000
000006  6041              STR      r1,[r0,#4]
;;;106    }
000008  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=1

                  UART_DisableInt PROC
;;;126     */
;;;127    void UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;128    {
;;;129        /* Disable UART specified interrupt */
;;;130        UART_DISABLE_INT(uart, u32InterruptFlag);
000002  ea220101          BIC      r1,r2,r1
000006  6041              STR      r1,[r0,#4]
;;;131    }
000008  4770              BX       lr
;;;132    
                          ENDP


                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_EnableFlowCtrl PROC
;;;142     */
;;;143    void UART_EnableFlowCtrl(UART_T* uart)
000000  6901              LDR      r1,[r0,#0x10]
;;;144    {
;;;145        /* Set RTS pin output is low level active */
;;;146        uart->MODEM |= UART_MODEM_RTSACTLV_Msk;
000002  f4417100          ORR      r1,r1,#0x200
000006  6101              STR      r1,[r0,#0x10]
;;;147    
;;;148        /* Set CTS pin input is low level active */
;;;149        uart->MODEMSTS |= UART_MODEMSTS_CTSACTLV_Msk;
000008  6941              LDR      r1,[r0,#0x14]
00000a  f4417180          ORR      r1,r1,#0x100
00000e  6141              STR      r1,[r0,#0x14]
;;;150    
;;;151        /* Set RTS and CTS auto flow control enable */
;;;152        uart->INTEN |= UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk;
000010  6841              LDR      r1,[r0,#4]
000012  f4415140          ORR      r1,r1,#0x3000
000016  6041              STR      r1,[r0,#4]
;;;153    }
000018  4770              BX       lr
;;;154    
                          ENDP


                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=1

                  UART_EnableInt PROC
;;;173     */
;;;174    void UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;175    {
;;;176        /* Enable UART specified interrupt */
;;;177        UART_ENABLE_INT(uart, u32InterruptFlag);
000002  4311              ORRS     r1,r1,r2
000004  6041              STR      r1,[r0,#4]
;;;178    }
000006  4770              BX       lr
;;;179    
                          ENDP


                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;190     */
;;;191    void UART_Open(UART_T* uart, uint32_t u32baudrate)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;192    {
;;;193        uint32_t u32UartClkSrcSel=0ul, u32UartClkDivNum=0ul;
;;;194        uint32_t u32ClkTbl[4] = {__HXT, 0ul, __LXT, __HIRC};
000004  4b46              LDR      r3,|L7.288|
000006  460f              MOV      r7,r1                 ;192
000008  4604              MOV      r4,r0                 ;192
00000a  cb0f              LDM      r3,{r0-r3}
00000c  b084              SUB      sp,sp,#0x10           ;192
00000e  2500              MOVS     r5,#0                 ;193
000010  e88d000f          STM      sp,{r0-r3}
;;;195        uint32_t u32Baud_Div = 0ul;
;;;196    
;;;197    
;;;198        if(uart==(UART_T*)UART0)
000014  f1a44180          SUB      r1,r4,#0x40000000
000018  462e              MOV      r6,r5                 ;193
;;;199        {
;;;200            /* Get UART clock source selection */
;;;201            u32UartClkSrcSel = ((uint32_t)(CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk)) >> CLK_CLKSEL1_UART0SEL_Pos;
00001a  f04f4080          MOV      r0,#0x40000000
00001e  f5b121e0          SUBS     r1,r1,#0x70000        ;198
000022  d019              BEQ      |L7.88|
;;;202            /* Get UART clock divider number */
;;;203            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
;;;204        }
;;;205        else if(uart==(UART_T*)UART1)
000024  f1a44180          SUB      r1,r4,#0x40000000
000028  f5b121e2          SUBS     r1,r1,#0x71000
00002c  d01b              BEQ      |L7.102|
;;;206        {
;;;207            /* Get UART clock source selection */
;;;208            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
;;;209            /* Get UART clock divider number */
;;;210            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
;;;211        }
;;;212        else if(uart==(UART_T*)UART2)
00002e  f1a44180          SUB      r1,r4,#0x40000000
000032  f5b121e4          SUBS     r1,r1,#0x72000
000036  d01d              BEQ      |L7.116|
;;;213        {
;;;214            /* Get UART clock source selection */
;;;215            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
;;;216            /* Get UART clock divider number */
;;;217            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
;;;218        }
;;;219        else if(uart==(UART_T*)UART3)
000038  f1a44180          SUB      r1,r4,#0x40000000
00003c  f5b121e6          SUBS     r1,r1,#0x73000
000040  d021              BEQ      |L7.134|
;;;220        {
;;;221            /* Get UART clock source selection */
;;;222            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART3SEL_Msk) >> CLK_CLKSEL3_UART3SEL_Pos;
;;;223            /* Get UART clock divider number */
;;;224            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART3DIV_Msk) >> CLK_CLKDIV4_UART3DIV_Pos;
;;;225        }
;;;226        else if(uart==(UART_T*)UART4)
000042  f1a44180          SUB      r1,r4,#0x40000000
000046  f5b121e8          SUBS     r1,r1,#0x74000
00004a  d025              BEQ      |L7.152|
;;;227        {
;;;228            /* Get UART clock source selection */
;;;229            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART4SEL_Msk) >> CLK_CLKSEL3_UART4SEL_Pos;
;;;230            /* Get UART clock divider number */
;;;231            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART4DIV_Msk) >> CLK_CLKDIV4_UART4DIV_Pos;
;;;232        }
;;;233        else if(uart==(UART_T*)UART5)
00004c  f1a44180          SUB      r1,r4,#0x40000000
000050  f5b121ea          SUBS     r1,r1,#0x75000
000054  d029              BEQ      |L7.170|
000056  e02f              B        |L7.184|
                  |L7.88|
000058  f8d01214          LDR      r1,[r0,#0x214]        ;201
00005c  f8d00220          LDR      r0,[r0,#0x220]        ;203
000060  f3c16501          UBFX     r5,r1,#24,#2          ;201
000064  e01e              B        |L7.164|
                  |L7.102|
000066  f8d01214          LDR      r1,[r0,#0x214]        ;208
00006a  f8d00220          LDR      r0,[r0,#0x220]        ;210
00006e  f3c16581          UBFX     r5,r1,#26,#2          ;208
000072  e01f              B        |L7.180|
                  |L7.116|
000074  f8d0121c          LDR      r1,[r0,#0x21c]        ;215
000078  f8d00230          LDR      r0,[r0,#0x230]        ;217
00007c  f3c16501          UBFX     r5,r1,#24,#2          ;215
000080  f000060f          AND      r6,r0,#0xf            ;217
000084  e018              B        |L7.184|
                  |L7.134|
000086  f8d0121c          LDR      r1,[r0,#0x21c]        ;222
00008a  f8d00230          LDR      r0,[r0,#0x230]        ;224
00008e  f3c16581          UBFX     r5,r1,#26,#2          ;222
000092  f3c01603          UBFX     r6,r0,#4,#4           ;224
000096  e00f              B        |L7.184|
                  |L7.152|
000098  f8d0121c          LDR      r1,[r0,#0x21c]        ;229
00009c  f8d00230          LDR      r0,[r0,#0x230]        ;231
0000a0  f3c17501          UBFX     r5,r1,#28,#2          ;229
                  |L7.164|
0000a4  f3c02603          UBFX     r6,r0,#8,#4           ;231
0000a8  e006              B        |L7.184|
                  |L7.170|
;;;234        {
;;;235            /* Get UART clock source selection */
;;;236            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART5SEL_Msk) >> CLK_CLKSEL3_UART5SEL_Pos;
0000aa  f8d0121c          LDR      r1,[r0,#0x21c]
;;;237            /* Get UART clock divider number */
;;;238            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART5DIV_Msk) >> CLK_CLKDIV4_UART5DIV_Pos;
0000ae  f8d00230          LDR      r0,[r0,#0x230]
0000b2  0f8d              LSRS     r5,r1,#30             ;236
                  |L7.180|
0000b4  f3c03603          UBFX     r6,r0,#12,#4
                  |L7.184|
;;;239        }
;;;240    
;;;241        /* Select UART function */
;;;242        uart->FUNCSEL = UART_FUNCSEL_UART;
0000b8  2000              MOVS     r0,#0
0000ba  6320              STR      r0,[r4,#0x30]
;;;243    
;;;244        /* Set UART line configuration */
;;;245        uart->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
0000bc  2003              MOVS     r0,#3
0000be  60e0              STR      r0,[r4,#0xc]
;;;246    
;;;247        /* Set UART Rx and RTS trigger level */
;;;248        uart->FIFO &= ~(UART_FIFO_RFITL_Msk | UART_FIFO_RTSTRGLV_Msk);
0000c0  68a0              LDR      r0,[r4,#8]
0000c2  f02000f0          BIC      r0,r0,#0xf0
0000c6  f4202070          BIC      r0,r0,#0xf0000
0000ca  60a0              STR      r0,[r4,#8]
0000cc  46e8              MOV      r8,sp                 ;194
;;;249    
;;;250        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;251        if(u32UartClkSrcSel == 1ul)
0000ce  2d01              CMP      r5,#1
0000d0  d102              BNE      |L7.216|
;;;252        {
;;;253            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
0000d2  f7fffffe          BL       CLK_GetPLLClockFreq
0000d6  9001              STR      r0,[sp,#4]
                  |L7.216|
;;;254        }
;;;255    
;;;256        /* Set UART baud rate */
;;;257        if(u32baudrate != 0ul)
0000d8  2f00              CMP      r7,#0
;;;258        {
;;;259            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
;;;260    
;;;261            if(u32Baud_Div > 0xFFFFul)
;;;262            {
;;;263                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
;;;264            }
;;;265            else
;;;266            {
;;;267                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
;;;268            }
;;;269        }
;;;270    }
0000da  bf04              ITT      EQ
0000dc  b004              ADDEQ    sp,sp,#0x10
0000de  e8bd81f0          POPEQ    {r4-r8,pc}
0000e2  f8581025          LDR      r1,[r8,r5,LSL #2]     ;259
0000e6  1c72              ADDS     r2,r6,#1              ;259
0000e8  fbb1f0f2          UDIV     r0,r1,r2              ;259
0000ec  eb000057          ADD      r0,r0,r7,LSR #1       ;259
0000f0  fbb0f0f7          UDIV     r0,r0,r7              ;259
0000f4  1e80              SUBS     r0,r0,#2              ;259
0000f6  f5b03f80          CMP      r0,#0x10000           ;261
0000fa  bf38              IT       CC                    ;267
0000fc  f0405040          ORRCC    r0,r0,#0x30000000     ;267
000100  d309              BCC      |L7.278|
000102  fbb1f0f2          UDIV     r0,r1,r2              ;263
000106  eb0000c7          ADD      r0,r0,r7,LSL #3       ;263
00010a  fbb0f0f7          UDIV     r0,r0,r7              ;263
00010e  f06f0101          MVN      r1,#1                 ;263
000112  eb011010          ADD      r0,r1,r0,LSR #4       ;263
                  |L7.278|
000116  6260              STR      r0,[r4,#0x24]         ;267
000118  b004              ADD      sp,sp,#0x10
00011a  e8bd81f0          POP      {r4-r8,pc}
;;;271    
                          ENDP

00011e  0000              DCW      0x0000
                  |L7.288|
                          DCD      ||.constdata||

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=2

                  UART_Read PROC
;;;283     */
;;;284    uint32_t UART_Read(UART_T* uart, uint8_t pu8RxBuf[], uint32_t u32ReadBytes)
000000  b430              PUSH     {r4,r5}
;;;285    {
;;;286        uint32_t  u32Count, u32delayno;
;;;287        uint32_t  u32Exit = 0ul;
000002  2500              MOVS     r5,#0
;;;288    
;;;289        for(u32Count = 0ul; u32Count < u32ReadBytes; u32Count++)
000004  462c              MOV      r4,r5
000006  2a00              CMP      r2,#0
000008  d916              BLS      |L8.56|
                  |L8.10|
;;;290        {
;;;291            u32delayno = 0ul;
;;;292    
;;;293            while(uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)   /* Check RX empty => failed */
00000a  6983              LDR      r3,[r0,#0x18]
00000c  f4134f80          TST      r3,#0x4000
;;;294            {
;;;295                u32delayno++;
000010  bf18              IT       NE
000012  2301              MOVNE    r3,#1
000014  d00a              BEQ      |L8.44|
000016  bf00              NOP                            ;293
                  |L8.24|
000018  f8d0c018          LDR      r12,[r0,#0x18]        ;293
00001c  f41c4f80          TST      r12,#0x4000           ;293
000020  d004              BEQ      |L8.44|
000022  1c5b              ADDS     r3,r3,#1              ;293
;;;296                if(u32delayno >= 0x40000000ul)
000024  f1b34f80          CMP      r3,#0x40000000
000028  d3f6              BCC      |L8.24|
00002a  e005              B        |L8.56|
                  |L8.44|
;;;297                {
;;;298                    u32Exit = 1ul;
;;;299                    break;
;;;300                }
;;;301                else
;;;302                {
;;;303                }
;;;304            }
;;;305    
;;;306            if(u32Exit == 1ul)
00002c  b925              CBNZ     r5,|L8.56|
;;;307            {
;;;308                break;
;;;309            }
;;;310            else
;;;311            {
;;;312                pu8RxBuf[u32Count] = (uint8_t)uart->DAT; /* Get Data from UART RX  */
00002e  6803              LDR      r3,[r0,#0]
000030  550b              STRB     r3,[r1,r4]
000032  1c64              ADDS     r4,r4,#1
000034  4294              CMP      r4,r2                 ;289
000036  d3e8              BCC      |L8.10|
                  |L8.56|
;;;313            }
;;;314        }
;;;315    
;;;316        return u32Count;
000038  4620              MOV      r0,r4
;;;317    
;;;318    }
00003a  bc30              POP      {r4,r5}
00003c  4770              BX       lr
;;;319    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=2

                  UART_SelectIrDAMode PROC
;;;458     */
;;;459    void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;460    {
;;;461        uint32_t u32UartClkSrcSel=0ul, u32UartClkDivNum=0ul;
;;;462        uint32_t u32ClkTbl[4ul] = {__HXT, 0ul, __LXT, __HIRC};
000004  4b43              LDR      r3,|L9.276|
000006  4690              MOV      r8,r2                 ;460
000008  460f              MOV      r7,r1                 ;460
00000a  4604              MOV      r4,r0                 ;460
00000c  cb0f              LDM      r3,{r0-r3}
00000e  b085              SUB      sp,sp,#0x14           ;460
000010  2500              MOVS     r5,#0                 ;461
000012  e88d000f          STM      sp,{r0-r3}
;;;463        uint32_t u32Baud_Div;
;;;464    
;;;465        /* Select IrDA function mode */
;;;466        uart->FUNCSEL = UART_FUNCSEL_IrDA;
000016  2002              MOVS     r0,#2
000018  462e              MOV      r6,r5                 ;461
00001a  6320              STR      r0,[r4,#0x30]
;;;467    
;;;468    
;;;469        if(uart==UART0)
;;;470        {
;;;471            /* Get UART clock source selection */
;;;472            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
00001c  0740              LSLS     r0,r0,#29
00001e  f1a44180          SUB      r1,r4,#0x40000000     ;469
000022  46e9              MOV      r9,sp                 ;462
000024  f5b121e0          SUBS     r1,r1,#0x70000        ;469
000028  d019              BEQ      |L9.94|
;;;473            /* Get UART clock divider number */
;;;474            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
;;;475        }
;;;476        else if(uart==UART1)
00002a  f1a44180          SUB      r1,r4,#0x40000000
00002e  f5b121e2          SUBS     r1,r1,#0x71000
000032  d01b              BEQ      |L9.108|
;;;477        {
;;;478            /* Get UART clock source selection */
;;;479            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
;;;480            /* Get UART clock divider number */
;;;481            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
;;;482        }
;;;483        else if(uart==UART2)
000034  f1a44180          SUB      r1,r4,#0x40000000
000038  f5b121e4          SUBS     r1,r1,#0x72000
00003c  d01d              BEQ      |L9.122|
;;;484        {
;;;485            /* Get UART clock source selection */
;;;486            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
;;;487            /* Get UART clock divider number */
;;;488            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
;;;489        }
;;;490        else if(uart==UART3)
00003e  f1a44180          SUB      r1,r4,#0x40000000
000042  f5b121e6          SUBS     r1,r1,#0x73000
000046  d021              BEQ      |L9.140|
;;;491        {
;;;492            /* Get UART clock source selection */
;;;493            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART3SEL_Msk) >> CLK_CLKSEL3_UART3SEL_Pos;
;;;494            /* Get UART clock divider number */
;;;495            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART3DIV_Msk) >> CLK_CLKDIV4_UART3DIV_Pos;
;;;496        }
;;;497        else if(uart==UART4)
000048  f1a44180          SUB      r1,r4,#0x40000000
00004c  f5b121e8          SUBS     r1,r1,#0x74000
000050  d025              BEQ      |L9.158|
;;;498        {
;;;499            /* Get UART clock source selection */
;;;500            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART4SEL_Msk) >> CLK_CLKSEL3_UART4SEL_Pos;
;;;501            /* Get UART clock divider number */
;;;502            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART4DIV_Msk) >> CLK_CLKDIV4_UART4DIV_Pos;
;;;503        }
;;;504        else if(uart==UART5)
000052  f1a44180          SUB      r1,r4,#0x40000000
000056  f5b121ea          SUBS     r1,r1,#0x75000
00005a  d029              BEQ      |L9.176|
00005c  e034              B        |L9.200|
                  |L9.94|
00005e  f8d01214          LDR      r1,[r0,#0x214]        ;472
000062  f8d00220          LDR      r0,[r0,#0x220]        ;474
000066  f3c16501          UBFX     r5,r1,#24,#2          ;472
00006a  e01e              B        |L9.170|
                  |L9.108|
00006c  f8d01214          LDR      r1,[r0,#0x214]        ;479
000070  f8d00220          LDR      r0,[r0,#0x220]        ;481
000074  f3c16581          UBFX     r5,r1,#26,#2          ;479
000078  e01f              B        |L9.186|
                  |L9.122|
00007a  f8d0121c          LDR      r1,[r0,#0x21c]        ;486
00007e  f8d00230          LDR      r0,[r0,#0x230]        ;488
000082  f3c16501          UBFX     r5,r1,#24,#2          ;486
000086  f000060f          AND      r6,r0,#0xf            ;488
00008a  e018              B        |L9.190|
                  |L9.140|
00008c  f8d0121c          LDR      r1,[r0,#0x21c]        ;493
000090  f8d00230          LDR      r0,[r0,#0x230]        ;495
000094  f3c16581          UBFX     r5,r1,#26,#2          ;493
000098  f3c01603          UBFX     r6,r0,#4,#4           ;495
00009c  e00f              B        |L9.190|
                  |L9.158|
00009e  f8d0121c          LDR      r1,[r0,#0x21c]        ;500
0000a2  f8d00230          LDR      r0,[r0,#0x230]        ;502
0000a6  f3c17501          UBFX     r5,r1,#28,#2          ;500
                  |L9.170|
0000aa  f3c02603          UBFX     r6,r0,#8,#4           ;502
0000ae  e006              B        |L9.190|
                  |L9.176|
;;;505        {
;;;506            /* Get UART clock source selection */
;;;507            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART5SEL_Msk) >> CLK_CLKSEL3_UART5SEL_Pos;
0000b0  f8d0121c          LDR      r1,[r0,#0x21c]
;;;508            /* Get UART clock divider number */
;;;509            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART5DIV_Msk) >> CLK_CLKDIV4_UART5DIV_Pos;
0000b4  f8d00230          LDR      r0,[r0,#0x230]
0000b8  0f8d              LSRS     r5,r1,#30             ;507
                  |L9.186|
0000ba  f3c03603          UBFX     r6,r0,#12,#4
                  |L9.190|
;;;510        }
;;;511    
;;;512    
;;;513        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;514        if(u32UartClkSrcSel == 1ul)
0000be  2d01              CMP      r5,#1
0000c0  d102              BNE      |L9.200|
;;;515        {
;;;516            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
0000c2  f7fffffe          BL       CLK_GetPLLClockFreq
0000c6  9001              STR      r0,[sp,#4]
                  |L9.200|
;;;517        }
;;;518        else
;;;519        {
;;;520        }
;;;521    
;;;522        /* Set UART IrDA baud rate in mode 0 */
;;;523        if(u32Buadrate != 0ul)
0000c8  b187              CBZ      r7,|L9.236|
;;;524        {
;;;525            u32Baud_Div = UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32Buadrate);
0000ca  f8590025          LDR      r0,[r9,r5,LSL #2]
0000ce  1c71              ADDS     r1,r6,#1
0000d0  fbb0f0f1          UDIV     r0,r0,r1
0000d4  eb0000c7          ADD      r0,r0,r7,LSL #3
0000d8  fbb0f0f7          UDIV     r0,r0,r7
0000dc  f06f0101          MVN      r1,#1
0000e0  eb011010          ADD      r0,r1,r0,LSR #4
;;;526    
;;;527            if(u32Baud_Div < 0xFFFFul)
0000e4  0c09              LSRS     r1,r1,#16
0000e6  4288              CMP      r0,r1
;;;528            {
;;;529                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
0000e8  bf38              IT       CC
0000ea  6260              STRCC    r0,[r4,#0x24]
                  |L9.236|
;;;530            }
;;;531            else
;;;532            {
;;;533            }
;;;534        }
;;;535    
;;;536        /* Configure IrDA relative settings */
;;;537        if(u32Direction == UART_IRDA_RXEN)
0000ec  f1b80f00          CMP      r8,#0
;;;538        {
;;;539            uart->IRDA |= UART_IRDA_RXINV_Msk;     /*Rx signal is inverse*/
;;;540            uart->IRDA &= ~UART_IRDA_TXEN_Msk;
;;;541        }
;;;542        else
;;;543        {
;;;544            uart->IRDA &= ~UART_IRDA_TXINV_Msk;    /*Tx signal is not inverse*/
0000f0  6aa0              LDR      r0,[r4,#0x28]
0000f2  bf0c              ITE      EQ                    ;539
0000f4  f0400040          ORREQ    r0,r0,#0x40           ;539
0000f8  f0200020          BICNE    r0,r0,#0x20
0000fc  62a0              STR      r0,[r4,#0x28]
;;;545            uart->IRDA |= UART_IRDA_TXEN_Msk;
0000fe  6aa0              LDR      r0,[r4,#0x28]
000100  bf0c              ITE      EQ                    ;540
000102  f0200002          BICEQ    r0,r0,#2              ;540
000106  f0400002          ORRNE    r0,r0,#2
00010a  62a0              STR      r0,[r4,#0x28]         ;540
;;;546        }
;;;547    
;;;548    }
00010c  b005              ADD      sp,sp,#0x14
00010e  e8bd83f0          POP      {r4-r9,pc}
;;;549    
                          ENDP

000112  0000              DCW      0x0000
                  |L9.276|
                          DCD      ||.constdata||+0x20

                          AREA ||i.UART_SelectLINMode||, CODE, READONLY, ALIGN=1

                  UART_SelectLINMode PROC
;;;588     */
;;;589    void UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength)
000000  2301              MOVS     r3,#1
;;;590    {
;;;591        /* Select LIN function mode */
;;;592        uart->FUNCSEL = UART_FUNCSEL_LIN;
000002  6303              STR      r3,[r0,#0x30]
;;;593    
;;;594        /* Select LIN function setting : Tx enable, Rx enable and break field length */
;;;595        uart->ALTCTL &= ~(UART_ALTCTL_LINTXEN_Msk | UART_ALTCTL_LINRXEN_Msk | UART_ALTCTL_BRKFL_Msk);
000004  6ac3              LDR      r3,[r0,#0x2c]
000006  f02303cf          BIC      r3,r3,#0xcf
00000a  62c3              STR      r3,[r0,#0x2c]
;;;596        uart->ALTCTL |= (u32Mode | (u32BreakLength << UART_ALTCTL_BRKFL_Pos));
00000c  6ac3              LDR      r3,[r0,#0x2c]
00000e  4311              ORRS     r1,r1,r2
000010  4319              ORRS     r1,r1,r3
000012  62c1              STR      r1,[r0,#0x2c]
;;;597    }
000014  4770              BX       lr
;;;598    
                          ENDP


                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=1

                  UART_SelectRS485Mode PROC
;;;564     */
;;;565    void UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr)
000000  2303              MOVS     r3,#3
;;;566    {
;;;567        /* Select UART RS485 function mode */
;;;568        uart->FUNCSEL = UART_FUNCSEL_RS485;
000002  6303              STR      r3,[r0,#0x30]
;;;569    
;;;570        /* Set RS585 configuration */
;;;571        uart->ALTCTL &= ~(UART_ALTCTL_RS485NMM_Msk | UART_ALTCTL_RS485AUD_Msk | UART_ALTCTL_RS485AAD_Msk | UART_ALTCTL_ADDRMV_Msk);
000004  6ac3              LDR      r3,[r0,#0x2c]
000006  f42363e0          BIC      r3,r3,#0x700
00000a  f023437f          BIC      r3,r3,#0xff000000
00000e  62c3              STR      r3,[r0,#0x2c]
;;;572        uart->ALTCTL |= (u32Mode | (u32Addr << UART_ALTCTL_ADDRMV_Pos));
000010  6ac3              LDR      r3,[r0,#0x2c]
000012  ea416102          ORR      r1,r1,r2,LSL #24
000016  4319              ORRS     r1,r1,r3
000018  62c1              STR      r1,[r0,#0x2c]
;;;573    }
00001a  4770              BX       lr
;;;574    
                          ENDP


                          AREA ||i.UART_SetLineConfig||, CODE, READONLY, ALIGN=2

                  UART_SetLineConfig PROC
;;;346     */
;;;347    void UART_SetLineConfig(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;348    {
000004  4699              MOV      r9,r3
;;;349        uint32_t u32UartClkSrcSel=0ul, u32UartClkDivNum=0ul;
;;;350        uint32_t u32ClkTbl[4ul] = {__HXT, 0ul, __LXT, __HIRC};
000006  4b43              LDR      r3,|L12.276|
000008  4692              MOV      r10,r2                ;348
00000a  460f              MOV      r7,r1                 ;348
00000c  4604              MOV      r4,r0                 ;348
00000e  b085              SUB      sp,sp,#0x14           ;348
000010  cb0f              LDM      r3,{r0-r3}
000012  f8ddb038          LDR      r11,[sp,#0x38]
000016  e88d000f          STM      sp,{r0-r3}
00001a  2500              MOVS     r5,#0                 ;349
;;;351        uint32_t u32Baud_Div = 0ul;
;;;352    
;;;353    
;;;354        if(uart==(UART_T*)UART0)
00001c  f1a44180          SUB      r1,r4,#0x40000000
000020  462e              MOV      r6,r5                 ;349
;;;355        {
;;;356            /* Get UART clock source selection */
;;;357            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
000022  f04f4080          MOV      r0,#0x40000000
000026  46e8              MOV      r8,sp                 ;350
000028  f5b121e0          SUBS     r1,r1,#0x70000        ;354
00002c  d019              BEQ      |L12.98|
;;;358            /* Get UART clock divider number */
;;;359            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
;;;360        }
;;;361        else if(uart==(UART_T*)UART1)
00002e  f1a44180          SUB      r1,r4,#0x40000000
000032  f5b121e2          SUBS     r1,r1,#0x71000
000036  d01b              BEQ      |L12.112|
;;;362        {
;;;363            /* Get UART clock source selection */
;;;364            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
;;;365            /* Get UART clock divider number */
;;;366            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
;;;367        }
;;;368        else if(uart==(UART_T*)UART2)
000038  f1a44180          SUB      r1,r4,#0x40000000
00003c  f5b121e4          SUBS     r1,r1,#0x72000
000040  d01d              BEQ      |L12.126|
;;;369        {
;;;370            /* Get UART clock source selection */
;;;371            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
;;;372            /* Get UART clock divider number */
;;;373            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
;;;374        }
;;;375        else if(uart==(UART_T*)UART3)
000042  f1a44180          SUB      r1,r4,#0x40000000
000046  f5b121e6          SUBS     r1,r1,#0x73000
00004a  d021              BEQ      |L12.144|
;;;376        {
;;;377            /* Get UART clock source selection */
;;;378            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART3SEL_Msk) >> CLK_CLKSEL3_UART3SEL_Pos;
;;;379            /* Get UART clock divider number */
;;;380            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART3DIV_Msk) >> CLK_CLKDIV4_UART3DIV_Pos;
;;;381        }
;;;382        else if(uart==(UART_T*)UART4)
00004c  f1a44180          SUB      r1,r4,#0x40000000
000050  f5b121e8          SUBS     r1,r1,#0x74000
000054  d025              BEQ      |L12.162|
;;;383        {
;;;384            /* Get UART clock source selection */
;;;385            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART4SEL_Msk) >> CLK_CLKSEL3_UART4SEL_Pos;
;;;386            /* Get UART clock divider number */
;;;387            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART4DIV_Msk) >> CLK_CLKDIV4_UART4DIV_Pos;
;;;388        }
;;;389        else if(uart==(UART_T*)UART5)
000056  f1a44180          SUB      r1,r4,#0x40000000
00005a  f5b121ea          SUBS     r1,r1,#0x75000
00005e  d029              BEQ      |L12.180|
000060  e034              B        |L12.204|
                  |L12.98|
000062  f8d01214          LDR      r1,[r0,#0x214]        ;357
000066  f8d00220          LDR      r0,[r0,#0x220]        ;359
00006a  f3c16501          UBFX     r5,r1,#24,#2          ;357
00006e  e01e              B        |L12.174|
                  |L12.112|
000070  f8d01214          LDR      r1,[r0,#0x214]        ;364
000074  f8d00220          LDR      r0,[r0,#0x220]        ;366
000078  f3c16581          UBFX     r5,r1,#26,#2          ;364
00007c  e01f              B        |L12.190|
                  |L12.126|
00007e  f8d0121c          LDR      r1,[r0,#0x21c]        ;371
000082  f8d00230          LDR      r0,[r0,#0x230]        ;373
000086  f3c16501          UBFX     r5,r1,#24,#2          ;371
00008a  f000060f          AND      r6,r0,#0xf            ;373
00008e  e018              B        |L12.194|
                  |L12.144|
000090  f8d0121c          LDR      r1,[r0,#0x21c]        ;378
000094  f8d00230          LDR      r0,[r0,#0x230]        ;380
000098  f3c16581          UBFX     r5,r1,#26,#2          ;378
00009c  f3c01603          UBFX     r6,r0,#4,#4           ;380
0000a0  e00f              B        |L12.194|
                  |L12.162|
0000a2  f8d0121c          LDR      r1,[r0,#0x21c]        ;385
0000a6  f8d00230          LDR      r0,[r0,#0x230]        ;387
0000aa  f3c17501          UBFX     r5,r1,#28,#2          ;385
                  |L12.174|
0000ae  f3c02603          UBFX     r6,r0,#8,#4           ;387
0000b2  e006              B        |L12.194|
                  |L12.180|
;;;390        {
;;;391            /* Get UART clock source selection */
;;;392            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART5SEL_Msk) >> CLK_CLKSEL3_UART5SEL_Pos;
0000b4  f8d0121c          LDR      r1,[r0,#0x21c]
;;;393            /* Get UART clock divider number */
;;;394            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART5DIV_Msk) >> CLK_CLKDIV4_UART5DIV_Pos;
0000b8  f8d00230          LDR      r0,[r0,#0x230]
0000bc  0f8d              LSRS     r5,r1,#30             ;392
                  |L12.190|
0000be  f3c03603          UBFX     r6,r0,#12,#4
                  |L12.194|
;;;395        }
;;;396    
;;;397        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;398        if(u32UartClkSrcSel == 1ul)
0000c2  2d01              CMP      r5,#1
0000c4  d102              BNE      |L12.204|
;;;399        {
;;;400            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
0000c6  f7fffffe          BL       CLK_GetPLLClockFreq
0000ca  9001              STR      r0,[sp,#4]
                  |L12.204|
;;;401        }
;;;402        else
;;;403        {
;;;404        }
;;;405    
;;;406        /* Set UART baud rate */
;;;407        if(u32baudrate != 0ul)
0000cc  b1d7              CBZ      r7,|L12.260|
;;;408        {
;;;409            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
0000ce  f8581025          LDR      r1,[r8,r5,LSL #2]
0000d2  1c72              ADDS     r2,r6,#1
0000d4  fbb1f0f2          UDIV     r0,r1,r2
0000d8  eb000057          ADD      r0,r0,r7,LSR #1
0000dc  fbb0f0f7          UDIV     r0,r0,r7
0000e0  1e80              SUBS     r0,r0,#2
;;;410    
;;;411            if(u32Baud_Div > 0xFFFFul)
0000e2  f5b03f80          CMP      r0,#0x10000
;;;412            {
;;;413                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
;;;414            }
;;;415            else
;;;416            {
;;;417                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
0000e6  bf38              IT       CC
0000e8  f0405040          ORRCC    r0,r0,#0x30000000
0000ec  d309              BCC      |L12.258|
0000ee  fbb1f0f2          UDIV     r0,r1,r2              ;413
0000f2  eb0000c7          ADD      r0,r0,r7,LSL #3       ;413
0000f6  fbb0f0f7          UDIV     r0,r0,r7              ;413
0000fa  f06f0101          MVN      r1,#1                 ;413
0000fe  eb011010          ADD      r0,r1,r0,LSR #4       ;413
                  |L12.258|
000102  6260              STR      r0,[r4,#0x24]         ;413
                  |L12.260|
;;;418            }
;;;419        }
;;;420    
;;;421        /* Set UART line configuration */
;;;422        uart->LINE = u32data_width | u32parity | u32stop_bits;
000104  ea4a0009          ORR      r0,r10,r9
000108  ea40000b          ORR      r0,r0,r11
00010c  60e0              STR      r0,[r4,#0xc]
;;;423    }
00010e  b005              ADD      sp,sp,#0x14
000110  e8bd8ff0          POP      {r4-r11,pc}
;;;424    
                          ENDP

                  |L12.276|
                          DCD      ||.constdata||+0x10

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;435     */
;;;436    void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;437    {
;;;438        /* Set time-out interrupt comparator */
;;;439        uart->TOUT = (uart->TOUT & ~UART_TOUT_TOIC_Msk) | (u32TOC);
000002  f02202ff          BIC      r2,r2,#0xff
000006  4311              ORRS     r1,r1,r2
000008  6201              STR      r1,[r0,#0x20]
;;;440    
;;;441        /* Set time-out counter enable */
;;;442        uart->INTEN |= UART_INTEN_TOCNTEN_Msk;
00000a  6841              LDR      r1,[r0,#4]
00000c  f4416100          ORR      r1,r1,#0x800
000010  6041              STR      r1,[r0,#4]
;;;443    }
000012  4770              BX       lr
;;;444    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;610     */
;;;611    uint32_t UART_Write(UART_T* uart, uint8_t pu8TxBuf[], uint32_t u32WriteBytes)
000000  b430              PUSH     {r4,r5}
;;;612    {
;;;613        uint32_t  u32Count, u32delayno;
;;;614        uint32_t  u32Exit = 0ul;
000002  2500              MOVS     r5,#0
;;;615    
;;;616        for(u32Count = 0ul; u32Count != u32WriteBytes; u32Count++)
000004  462c              MOV      r4,r5
000006  b1aa              CBZ      r2,|L14.52|
                  |L14.8|
;;;617        {
;;;618            u32delayno = 0ul;
;;;619            while((uart->FIFOSTS & UART_FIFOSTS_TXEMPTYF_Msk) == 0ul)   /* Wait Tx empty and Time-out manner */
000008  6983              LDR      r3,[r0,#0x18]
00000a  f0135f80          TST      r3,#0x10000000
;;;620            {
;;;621                u32delayno++;
00000e  bf08              IT       EQ
000010  2301              MOVEQ    r3,#1
000012  d109              BNE      |L14.40|
000014  e003              B        |L14.30|
                  |L14.22|
000016  1c5b              ADDS     r3,r3,#1              ;619
;;;622                if(u32delayno >= 0x40000000ul)
000018  f1b34f80          CMP      r3,#0x40000000
00001c  d20a              BCS      |L14.52|
                  |L14.30|
00001e  f8d0c018          LDR      r12,[r0,#0x18]        ;619
000022  f01c5f80          TST      r12,#0x10000000       ;619
000026  d0f6              BEQ      |L14.22|
                  |L14.40|
;;;623                {
;;;624                    u32Exit = 1ul;
;;;625                    break;
;;;626                }
;;;627                else
;;;628                {
;;;629                }
;;;630            }
;;;631    
;;;632            if(u32Exit == 1ul)
000028  b925              CBNZ     r5,|L14.52|
;;;633            {
;;;634                break;
;;;635            }
;;;636            else
;;;637            {
;;;638                uart->DAT = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
00002a  5d0b              LDRB     r3,[r1,r4]
00002c  6003              STR      r3,[r0,#0]
00002e  1c64              ADDS     r4,r4,#1
000030  4294              CMP      r4,r2                 ;616
000032  d1e9              BNE      |L14.8|
                  |L14.52|
;;;639            }
;;;640        }
;;;641    
;;;642        return u32Count;
000034  4620              MOV      r0,r4
;;;643    
;;;644    }
000036  bc30              POP      {r4,r5}
000038  4770              BX       lr
;;;645    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x00b71b00
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x00b71b00
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x00b71b00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 402
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____RRX|
#line 587
|__asm___6_uart_c_f12f5b44____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
