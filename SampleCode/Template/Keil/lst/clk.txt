; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -I..\Coremark -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DMAIN_HAS_NOARGC --omf_browse=.\obj\clk.crf ..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;28       */
;;;29     void CLK_DisableCKO(void)
000000  4802              LDR      r0,|L1.12|
000002  6801              LDR      r1,[r0,#0]
000004  f0210140          BIC      r1,r1,#0x40
000008  6001              STR      r1,[r0,#0]
;;;30     {
;;;31         /* Disable CKO clock source */
;;;32         CLK_DisableModuleClock(CLKO_MODULE);
;;;33     }
00000a  4770              BX       lr
;;;34     
                          ENDP

                  |L1.12|
                          DCD      0x40000208

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;735      */
;;;736    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  f000011f          AND      r1,r0,#0x1f
;;;737    {
;;;738        uint32_t u32tmpVal = 0UL, u32tmpAddr = 0UL;
;;;739    
;;;740        u32tmpVal = ~(1UL << MODULE_IP_EN_Pos(u32ModuleIdx));
000004  2201              MOVS     r2,#1
000006  fa02f101          LSL      r1,r2,r1
;;;741        u32tmpAddr = (uint32_t)&CLK->AHBCLK;
00000a  4a04              LDR      r2,|L2.28|
;;;742        u32tmpAddr += ((MODULE_APBCLK(u32ModuleIdx) * 4UL));
00000c  0f80              LSRS     r0,r0,#30
00000e  eb020080          ADD      r0,r2,r0,LSL #2
;;;743    
;;;744        *(uint32_t *)u32tmpAddr &= u32tmpVal;
000012  6802              LDR      r2,[r0,#0]
000014  ea220101          BIC      r1,r2,r1
000018  6001              STR      r1,[r0,#0]
;;;745    }
00001a  4770              BX       lr
;;;746    
                          ENDP

                  |L2.28|
                          DCD      0x40000204

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=1

                  CLK_DisablePLL PROC
;;;910      */
;;;911    void CLK_DisablePLL(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;912    {
;;;913        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000004  f8d01240          LDR      r1,[r0,#0x240]
000008  f4413180          ORR      r1,r1,#0x10000
00000c  f8c01240          STR      r1,[r0,#0x240]
;;;914    }
000010  4770              BX       lr
;;;915    
                          ENDP


                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=1

                  CLK_DisableSysTick PROC
;;;989      */
;;;990    void CLK_DisableSysTick(void)
000000  f04f21e0          MOV      r1,#0xe000e000
;;;991    {
;;;992        /* Set System Tick counter disabled */
;;;993        SysTick->CTRL = 0UL;
000004  2000              MOVS     r0,#0
000006  6108              STR      r0,[r1,#0x10]
;;;994    }
000008  4770              BX       lr
;;;995    
                          ENDP


                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=1

                  CLK_DisableXtalRC PROC
;;;595      */
;;;596    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;597    {
;;;598        CLK->PWRCTL &= ~u32ClkMask;
000004  f8d12200          LDR      r2,[r1,#0x200]
000008  ea220000          BIC      r0,r2,r0
00000c  f8c10200          STR      r0,[r1,#0x200]
;;;599    }
000010  4770              BX       lr
;;;600    
                          ENDP


                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;51       */
;;;52     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  ea411142          ORR      r1,r1,r2,LSL #5
;;;53     {
;;;54         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;55         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | (u32ClkDiv) | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
000004  f04f4280          MOV      r2,#0x40000000
000008  f0410110          ORR      r1,r1,#0x10
00000c  f8c21260          STR      r1,[r2,#0x260]
000010  4905              LDR      r1,|L6.40|
000012  680a              LDR      r2,[r1,#0]
000014  f0420240          ORR      r2,r2,#0x40
000018  600a              STR      r2,[r1,#0]
00001a  4904              LDR      r1,|L6.44|
00001c  680a              LDR      r2,[r1,#0]
00001e  f0225240          BIC      r2,r2,#0x30000000
000022  4310              ORRS     r0,r0,r2
000024  6008              STR      r0,[r1,#0]
;;;56     
;;;57         /* Enable CKO clock source */
;;;58         CLK_EnableModuleClock(CLKO_MODULE);
;;;59     
;;;60         /* Select CKO clock source */
;;;61         CLK_SetModuleClock(CLKO_MODULE, u32ClkSrc, 0UL);
;;;62     }
000026  4770              BX       lr
;;;63     
                          ENDP

                  |L6.40|
                          DCD      0x40000208
                  |L6.44|
                          DCD      0x40000214

                          AREA ||i.CLK_EnableDPDWKPin||, CODE, READONLY, ALIGN=1

                  CLK_EnableDPDWKPin PROC
;;;1037   
;;;1038   void CLK_EnableDPDWKPin(uint32_t u32TriggerType)
000000  f04f4180          MOV      r1,#0x40000000
;;;1039   {
;;;1040       CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN_Msk)) | u32TriggerType;
000004  f8d12290          LDR      r2,[r1,#0x290]
000008  f4223240          BIC      r2,r2,#0x30000
00000c  4310              ORRS     r0,r0,r2
00000e  f8c10290          STR      r0,[r1,#0x290]
;;;1041   }
000012  4770              BX       lr
;;;1042   
                          ENDP


                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;662      */
;;;663    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  f000011f          AND      r1,r0,#0x1f
;;;664    {
;;;665        uint32_t u32tmpVal = 0UL, u32tmpAddr = 0UL;
;;;666    
;;;667        u32tmpVal = (1UL << MODULE_IP_EN_Pos(u32ModuleIdx));
000004  2201              MOVS     r2,#1
000006  fa02f101          LSL      r1,r2,r1
;;;668        u32tmpAddr = (uint32_t)&CLK->AHBCLK;
00000a  4a04              LDR      r2,|L8.28|
;;;669        u32tmpAddr += ((MODULE_APBCLK(u32ModuleIdx) * 4UL));
00000c  0f80              LSRS     r0,r0,#30
00000e  eb020080          ADD      r0,r2,r0,LSL #2
;;;670    
;;;671        *(volatile uint32_t *)u32tmpAddr |= u32tmpVal;
000012  6802              LDR      r2,[r0,#0]
000014  4311              ORRS     r1,r1,r2
000016  6001              STR      r1,[r0,#0]
;;;672    }
000018  4770              BX       lr
;;;673    
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x40000204

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;757      */
;;;758    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;759    {
000004  f04f4280          MOV      r2,#0x40000000
000008  b084              SUB      sp,sp,#0x10
00000a  f8d23240          LDR      r3,[r2,#0x240]
00000e  f4433380          ORR      r3,r3,#0x10000
000012  f8c23240          STR      r3,[r2,#0x240]
;;;760        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC, u32PllClk;
;;;761        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR, u32MinNO, u32basFreq;
;;;762    
;;;763        /* Disable PLL first to avoid unstable when setting PLL */
;;;764        CLK_DisablePLL();
;;;765    
;;;766        /* PLL source clock is from HXT */
;;;767        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;768        {
;;;769            /* Enable HXT clock */
;;;770            CLK->PWRCTL |= CLK_PWRCTL_HXTEN_Msk;
;;;771    
;;;772            /* Wait for HXT clock ready */
;;;773            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;774    
;;;775            /* Select PLL source clock from HXT */
;;;776            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
;;;777            u32PllSrcClk = __HXT;
000016  4c80              LDR      r4,|L9.536|
;;;778    
;;;779            /* u32NR start from 2 */
;;;780            u32NR = 2UL;
;;;781        }
;;;782    
;;;783        /* PLL source clock is from HIRC */
;;;784        else
;;;785        {
;;;786            /* Enable HIRC clock */
;;;787            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000018  f8d23200          LDR      r3,[r2,#0x200]
00001c  b388              CBZ      r0,|L9.130|
00001e  f0430304          ORR      r3,r3,#4
000022  f8c23200          STR      r3,[r2,#0x200]
000026  f8d23250          LDR      r3,[r2,#0x250]
;;;788    
;;;789            /* Wait for HIRC clock ready */
;;;790            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00002a  f04f0c10          MOV      r12,#0x10
00002e  ea3c0303          BICS     r3,r12,r3
000032  bf18              IT       NE
000034  4b79              LDRNE    r3,|L9.540|
000036  d008              BEQ      |L9.74|
                  |L9.56|
000038  f8d25250          LDR      r5,[r2,#0x250]
00003c  ea3c0505          BICS     r5,r12,r5
000040  d003              BEQ      |L9.74|
000042  1e1d              SUBS     r5,r3,#0
000044  f1a30301          SUB      r3,r3,#1
000048  dcf6              BGT      |L9.56|
                  |L9.74|
;;;791    
;;;792            /* Select PLL source clock from HIRC */
;;;793            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC;
00004a  f44f2200          MOV      r2,#0x80000
00004e  bf00              NOP      
                  |L9.80|
000050  e9cd4200          STRD     r4,r2,[sp,#0]
;;;794            u32PllSrcClk = __HIRC;
;;;795    
;;;796            /* u32NR start from 4 when FIN = 22.1184MHz to avoid calculation overflow */
;;;797            u32NR = 4UL;
;;;798        }
;;;799    
;;;800        if((u32PllFreq <= FREQ_500MHZ) && (u32PllFreq >= FREQ_50MHZ))
000054  f8df81c8          LDR      r8,|L9.544|
000058  4b72              LDR      r3,|L9.548|
00005a  eb010208          ADD      r2,r1,r8
00005e  429a              CMP      r2,r3
000060  d87d              BHI      |L9.350|
;;;801        {
;;;802    
;;;803            /* Find best solution */
;;;804            u32Min = (uint32_t) - 1;
;;;805            u32MinNR = 0UL;
000062  2700              MOVS     r7,#0
;;;806            u32MinNF = 0UL;
;;;807            u32MinNO = 0UL;
;;;808            u32basFreq = u32PllFreq;
;;;809    
;;;810            for(u32NO = 1UL; u32NO <= 4UL; u32NO++)
;;;811            {
;;;812                /* Break when get good results */
;;;813                if (u32Min == 0UL)
;;;814                {
;;;815                    break;
;;;816                }
;;;817    
;;;818                if (u32NO != 3UL)
;;;819                {
;;;820    
;;;821                    if(u32NO == 4UL)
;;;822                    {
;;;823                        u32PllFreq = u32basFreq << 2;
;;;824                    }
;;;825                    else if(u32NO == 2UL)
;;;826                    {
;;;827                        u32PllFreq = u32basFreq << 1;
;;;828                    }
;;;829                    else
;;;830                    {
;;;831                    }
;;;832    
;;;833                    for(u32NR = 2UL; u32NR <= 32UL; u32NR++)
000064  008a              LSLS     r2,r1,#2
000066  2001              MOVS     r0,#1                 ;810
000068  2302              MOVS     r3,#2
00006a  9203              STR      r2,[sp,#0xc]          ;827
00006c  004a              LSLS     r2,r1,#1              ;827
00006e  f04f3cff          MOV      r12,#0xffffffff       ;804
000072  463e              MOV      r6,r7                 ;806
000074  463d              MOV      r5,r7                 ;807
;;;834                    {
;;;835                        /* Break when get good results */
;;;836                        if (u32Min == 0UL)
;;;837                        {
;;;838                            break;
;;;839                        }
;;;840    
;;;841                        u32Tmp = u32PllSrcClk / u32NR;
;;;842                        if((u32Tmp >= 4000000UL) && (u32Tmp <= 8000000UL))
;;;843                        {
;;;844                            for(u32NF = 2UL; u32NF <= 513UL; u32NF++)
;;;845                            {
;;;846                                /* u32Tmp2 is shifted 2 bits to avoid overflow */
;;;847                                u32Tmp2 = (((u32Tmp * 2UL) >> 2) * u32NF);
;;;848    
;;;849                                if((u32Tmp2 >= FREQ_50MHZ) && (u32Tmp2 <= FREQ_125MHZ))
000076  f8dfa1b0          LDR      r10,|L9.552|
00007a  f2402b01          MOV      r11,#0x201            ;844
00007e  9202              STR      r2,[sp,#8]            ;810
000080  e02d              B        |L9.222|
                  |L9.130|
000082  e7ff              B        |L9.132|
                  |L9.132|
000084  f0430301          ORR      r3,r3,#1              ;770
000088  f8c23200          STR      r3,[r2,#0x200]        ;770
00008c  f8d23250          LDR      r3,[r2,#0x250]        ;770
000090  f04f0c01          MOV      r12,#1                ;773
000094  ea3c0303          BICS     r3,r12,r3             ;773
000098  bf18              IT       NE                    ;773
00009a  4b60              LDRNE    r3,|L9.540|
00009c  d009              BEQ      |L9.178|
00009e  bf00              NOP                            ;773
                  |L9.160|
0000a0  f8d25250          LDR      r5,[r2,#0x250]        ;773
0000a4  ea3c0505          BICS     r5,r12,r5             ;773
0000a8  d003              BEQ      |L9.178|
0000aa  1e1d              SUBS     r5,r3,#0              ;773
0000ac  f1a30301          SUB      r3,r3,#1              ;773
0000b0  dcf6              BGT      |L9.160|
                  |L9.178|
0000b2  2200              MOVS     r2,#0                 ;776
0000b4  e7cc              B        |L9.80|
0000b6  bf00              NOP                            ;813
                  |L9.184|
0000b8  f1bc0f00          CMP      r12,#0                ;813
0000bc  d03c              BEQ      |L9.312|
0000be  2803              CMP      r0,#3                 ;818
0000c0  bf08              IT       EQ                    ;810
0000c2  2004              MOVEQ    r0,#4                 ;810
0000c4  d0f8              BEQ      |L9.184|
0000c6  2804              CMP      r0,#4                 ;821
0000c8  bf08              IT       EQ                    ;821
0000ca  9903              LDREQ    r1,[sp,#0xc]          ;821
0000cc  d002              BEQ      |L9.212|
0000ce  2802              CMP      r0,#2                 ;825
0000d0  bf08              IT       EQ                    ;825
0000d2  9902              LDREQ    r1,[sp,#8]            ;825
                  |L9.212|
0000d4  2302              MOVS     r3,#2                 ;833
0000d6  e002              B        |L9.222|
                  |L9.216|
0000d8  f1bc0f00          CMP      r12,#0                ;836
0000dc  d029              BEQ      |L9.306|
                  |L9.222|
0000de  9a00              LDR      r2,[sp,#0]            ;841
0000e0  fbb2f4f3          UDIV     r4,r2,r3              ;841
0000e4  f5a41974          SUB      r9,r4,#0x3d0000       ;842
0000e8  4a50              LDR      r2,|L9.556|
0000ea  f5a96910          SUB      r9,r9,#0x900          ;842
0000ee  4591              CMP      r9,r2                 ;842
0000f0  bf9c              ITT      LS                    ;844
0000f2  2202              MOVLS    r2,#2                 ;844
0000f4  f3c4095d          UBFXLS   r9,r4,#1,#30          ;847
0000f8  d818              BHI      |L9.300|
0000fa  bf00              NOP                            ;847
                  |L9.252|
0000fc  fb09f402          MUL      r4,r9,r2              ;847
000100  eb040e08          ADD      lr,r4,r8
000104  45d6              CMP      lr,r10
000106  d80e              BHI      |L9.294|
;;;850                                {
;;;851                                    u32Tmp3 = (u32Tmp2 > (u32PllFreq>>2)) ? u32Tmp2 - (u32PllFreq>>2) : (u32PllFreq>>2) - u32Tmp2;
000108  ebb40f91          CMP      r4,r1,LSR #2
00010c  bf8c              ITE      HI
00010e  eba40491          SUBHI    r4,r4,r1,LSR #2
000112  ebc40491          RSBLS    r4,r4,r1,LSR #2
;;;852                                    if(u32Tmp3 < u32Min)
000116  4564              CMP      r4,r12
000118  d205              BCS      |L9.294|
;;;853                                    {
;;;854                                        u32Min = u32Tmp3;
00011a  ea5f0c04          MOVS     r12,r4
;;;855                                        u32MinNR = u32NR;
00011e  461f              MOV      r7,r3
;;;856                                        u32MinNF = u32NF;
000120  4616              MOV      r6,r2
;;;857                                        u32MinNO = u32NO;
000122  4605              MOV      r5,r0
;;;858    
;;;859                                        /* Break when get good results */
;;;860                                        if(u32Min == 0UL)
000124  d002              BEQ      |L9.300|
                  |L9.294|
000126  1c52              ADDS     r2,r2,#1
000128  4593              CMP      r11,r2                ;844
00012a  d2e7              BCS      |L9.252|
                  |L9.300|
00012c  1c5b              ADDS     r3,r3,#1              ;844
00012e  2b20              CMP      r3,#0x20              ;833
000130  d9d2              BLS      |L9.216|
                  |L9.306|
000132  1c40              ADDS     r0,r0,#1              ;833
000134  2804              CMP      r0,#4                 ;810
000136  d9bf              BLS      |L9.184|
                  |L9.312|
;;;861                                        {
;;;862                                            break;
;;;863                                        }
;;;864                                    }
;;;865                                }
;;;866                            }
;;;867                        }
;;;868                    }
;;;869                }
;;;870            }
;;;871    
;;;872            /* Enable and apply new PLL setting. */
;;;873            CLK->PLLCTL = u32CLK_SRC | ((u32MinNO - 1UL) << 14) | ((u32MinNR - 1UL) << 9) | (u32MinNF - 2UL);
000138  483d              LDR      r0,|L9.560|
00013a  eb003185          ADD      r1,r0,r5,LSL #14
00013e  9801              LDR      r0,[sp,#4]
000140  4308              ORRS     r0,r0,r1
000142  493c              LDR      r1,|L9.564|
000144  eb012147          ADD      r1,r1,r7,LSL #9
000148  4308              ORRS     r0,r0,r1
00014a  1eb1              SUBS     r1,r6,#2
00014c  4308              ORRS     r0,r0,r1
00014e  f04f4180          MOV      r1,#0x40000000
000152  f8c10240          STR      r0,[r1,#0x240]
;;;874    
;;;875            /* Wait for PLL clock stable */
;;;876            CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
000156  2304              MOVS     r3,#4
000158  f8d10250          LDR      r0,[r1,#0x250]
00015c  e000              B        |L9.352|
                  |L9.350|
00015e  e018              B        |L9.402|
                  |L9.352|
000160  ea330000          BICS     r0,r3,r0
000164  bf18              IT       NE
000166  4a2d              LDRNE    r2,|L9.540|
000168  d009              BEQ      |L9.382|
00016a  bf00              NOP      
                  |L9.364|
00016c  f8d10250          LDR      r0,[r1,#0x250]
000170  ea330000          BICS     r0,r3,r0
000174  d003              BEQ      |L9.382|
000176  1e10              SUBS     r0,r2,#0
000178  f1a20201          SUB      r2,r2,#1
00017c  dcf6              BGT      |L9.364|
                  |L9.382|
;;;877    
;;;878            /* Actual PLL output clock frequency */
;;;879            u32PllClk = u32PllSrcClk / (u32MinNO * (u32MinNR)) * (u32MinNF) * 2UL;
00017e  9800              LDR      r0,[sp,#0]
000180  fb05f107          MUL      r1,r5,r7
000184  fbb0f0f1          UDIV     r0,r0,r1
000188  4370              MULS     r0,r6,r0
;;;880        }
;;;881        else
;;;882        {
;;;883            /* Wrong frequency request. Just return default setting. */
;;;884            /* Apply default PLL setting and return */
;;;885            if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;886            {
;;;887                CLK->PLLCTL = CLK_PLLCTL_192MHz_HXT;
;;;888            }
;;;889            else
;;;890            {
;;;891                CLK->PLLCTL = CLK_PLLCTL_192MHz_HIRC;
;;;892            }
;;;893    
;;;894            /* Wait for PLL clock stable */
;;;895            CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;896    
;;;897            /* Actual PLL output clock frequency */
;;;898            u32PllClk = CLK_GetPLLClockFreq();
;;;899        }
;;;900    
;;;901        return u32PllClk;
;;;902    }
00018a  b004              ADD      sp,sp,#0x10
00018c  0040              LSLS     r0,r0,#1              ;879
00018e  e8bd8ff0          POP      {r4-r11,pc}
                  |L9.402|
000192  2800              CMP      r0,#0                 ;885
000194  bf0c              ITE      EQ                    ;887
000196  f244211e          MOVEQ    r1,#0x421e            ;887
00019a  4927              LDRNE    r1,|L9.568|
00019c  f04f4080          MOV      r0,#0x40000000        ;891
0001a0  f8c01240          STR      r1,[r0,#0x240]        ;891
0001a4  4602              MOV      r2,r0                 ;891
0001a6  f8d00250          LDR      r0,[r0,#0x250]        ;891
0001aa  2104              MOVS     r1,#4                 ;895
0001ac  ea310000          BICS     r0,r1,r0              ;895
0001b0  bf18              IT       NE                    ;895
0001b2  481a              LDRNE    r0,|L9.540|
0001b4  d009              BEQ      |L9.458|
0001b6  bf00              NOP                            ;885
                  |L9.440|
0001b8  f8d23250          LDR      r3,[r2,#0x250]        ;885
0001bc  ea310303          BICS     r3,r1,r3              ;885
0001c0  d003              BEQ      |L9.458|
0001c2  1e03              SUBS     r3,r0,#0              ;885
0001c4  f1a00001          SUB      r0,r0,#1              ;885
0001c8  dcf6              BGT      |L9.440|
                  |L9.458|
0001ca  491c              LDR      r1,|L9.572|
0001cc  2000              MOVS     r0,#0                 ;885
0001ce  6809              LDR      r1,[r1,#0]            ;885
0001d0  9100              STR      r1,[sp,#0]            ;885
0001d2  f8d21240          LDR      r1,[r2,#0x240]        ;885
0001d6  f4112fa0          TST      r1,#0x50000           ;885
0001da  bf1c              ITT      NE
0001dc  b004              ADDNE    sp,sp,#0x10
0001de  e8bd8ff0          POPNE    {r4-r11,pc}
0001e2  f4113f00          TST      r1,#0x20000
0001e6  bf1e              ITTT     NE
0001e8  4620              MOVNE    r0,r4
0001ea  b004              ADDNE    sp,sp,#0x10
0001ec  e8bd8ff0          POPNE    {r4-r11,pc}
0001f0  f3c13281          UBFX     r2,r1,#14,#2
0001f4  4b12              LDR      r3,|L9.576|
0001f6  f81d0002          LDRB     r0,[sp,r2]
0001fa  f3c10208          UBFX     r2,r1,#0,#9
0001fe  1c92              ADDS     r2,r2,#2
000200  f3c12144          UBFX     r1,r1,#9,#5
000204  435a              MULS     r2,r3,r2
000206  1c49              ADDS     r1,r1,#1
000208  fb11f000          SMULBB   r0,r1,r0
00020c  fbb2f0f0          UDIV     r0,r2,r0
000210  b004              ADD      sp,sp,#0x10
000212  00c0              LSLS     r0,r0,#3
000214  e8bd8ff0          POP      {r4-r11,pc}
;;;903    
                          ENDP

                  |L9.536|
                          DCD      0x00b71b00
                  |L9.540|
                          DCD      0x0020f57f
                  |L9.544|
                          DCD      0xfd050f80
                  |L9.548|
                          DCD      0x1ad27480
                  |L9.552|
                          DCD      0x047868c0
                  |L9.556|
                          DCD      0x003d0900
                  |L9.560|
                          DCD      0xffffc000
                  |L9.564|
                          DCD      0xfffffe00
                  |L9.568|
                          DCD      0x0008421e
                  |L9.572|
                          DCD      ||i.CLK_GetPLLClockFreq||+0x50
                  |L9.576|
                          DCD      0x002dc6c0

                          AREA ||i.CLK_EnableSPDWKPin||, CODE, READONLY, ALIGN=2

                  CLK_EnableSPDWKPin PROC
;;;1072    */
;;;1073   void CLK_EnableSPDWKPin(uint32_t u32Port, uint32_t u32Pin, uint32_t u32TriggerType, uint32_t u32DebounceEn)
000000  f8dfc020          LDR      r12,|L10.36|
;;;1074   {
;;;1075       uint32_t u32tmpAddr = 0UL;
;;;1076       uint32_t u32tmpVal = 0UL;
;;;1077   
;;;1078       /* GPx Stand-by Power-down Wake-up Pin Select */
;;;1079       u32tmpAddr = (uint32_t)&CLK->PASWKCTL;
;;;1080       u32tmpAddr += (0x4UL * u32Port);
000004  eb0c0080          ADD      r0,r12,r0,LSL #2
;;;1081   
;;;1082       u32tmpVal = inpw((uint32_t *)u32tmpAddr);
000008  f8d0c000          LDR      r12,[r0,#0]
;;;1083       u32tmpVal = (u32tmpVal & ~(CLK_PASWKCTL_WKPSEL_Msk | CLK_PASWKCTL_PRWKEN_Msk | CLK_PASWKCTL_PFWKEN_Msk | CLK_PASWKCTL_DBEN_Msk | CLK_PASWKCTL_WKEN_Msk)) |
00000c  f02c0cf7          BIC      r12,r12,#0xf7
000010  f42c7c80          BIC      r12,r12,#0x100
000014  ea4c1101          ORR      r1,r12,r1,LSL #4
000018  4311              ORRS     r1,r1,r2
00001a  4319              ORRS     r1,r1,r3
00001c  f0410101          ORR      r1,r1,#1
;;;1084                   (u32Pin << CLK_PASWKCTL_WKPSEL_Pos) | u32TriggerType | u32DebounceEn | CLK_SPDWKPIN_ENABLE;
;;;1085       outpw((uint32_t *)u32tmpAddr, u32tmpVal);
000020  6001              STR      r1,[r0,#0]
;;;1086   }
000022  4770              BX       lr
;;;1087   
                          ENDP

                  |L10.36|
                          DCD      0x400002a0

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=1

                  CLK_EnableSysTick PROC
;;;958      */
;;;959    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  b410              PUSH     {r4}
;;;960    {
;;;961        /* Set System Tick counter disabled */
;;;962        SysTick->CTRL = 0UL;
000002  f04f22e0          MOV      r2,#0xe000e000
000006  2300              MOVS     r3,#0
000008  6113              STR      r3,[r2,#0x10]
;;;963    
;;;964        /* Set System Tick clock source */
;;;965        if( u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK )
00000a  2804              CMP      r0,#4
00000c  d010              BEQ      |L11.48|
;;;966        {
;;;967            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
;;;968        }
;;;969        else
;;;970        {
;;;971            CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
00000e  f04f4c80          MOV      r12,#0x40000000
000012  f8dc4210          LDR      r4,[r12,#0x210]
000016  f0240438          BIC      r4,r4,#0x38
00001a  4320              ORRS     r0,r0,r4
00001c  f8cc0210          STR      r0,[r12,#0x210]
                  |L11.32|
;;;972        }
;;;973    
;;;974        /* Set System Tick reload value */
;;;975        SysTick->LOAD = u32Count;
000020  6151              STR      r1,[r2,#0x14]
;;;976    
;;;977        /* Clear System Tick current value and counter flag */
;;;978        SysTick->VAL = 0UL;
000022  6193              STR      r3,[r2,#0x18]
;;;979    
;;;980        /* Set System Tick interrupt enabled and counter enabled */
;;;981        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
000024  6910              LDR      r0,[r2,#0x10]
000026  f0400003          ORR      r0,r0,#3
00002a  6110              STR      r0,[r2,#0x10]
;;;982    }
00002c  bc10              POP      {r4}
00002e  4770              BX       lr
                  |L11.48|
000030  6910              LDR      r0,[r2,#0x10]         ;967
000032  f0400004          ORR      r0,r0,#4              ;967
000036  6110              STR      r0,[r2,#0x10]         ;967
000038  e7f2              B        |L11.32|
;;;983    
                          ENDP


                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=1

                  CLK_EnableXtalRC PROC
;;;579      */
;;;580    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;581    {
;;;582        CLK->PWRCTL |= u32ClkMask;
000004  f8d12200          LDR      r2,[r1,#0x200]
000008  4310              ORRS     r0,r0,r2
00000a  f8c10200          STR      r0,[r1,#0x200]
;;;583    }
00000e  4770              BX       lr
;;;584    
                          ENDP


                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;289      */
;;;290    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;291    {
;;;292        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;293        return SystemCoreClock;
000006  4801              LDR      r0,|L13.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;294    }
00000a  bd10              POP      {r4,pc}
;;;295    
                          ENDP

                  |L13.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;276      */
;;;277    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;278    {
;;;279        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;280        return SystemCoreClock;
000006  4801              LDR      r0,|L14.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;281    }
00000a  bd10              POP      {r4,pc}
;;;282    
                          ENDP

                  |L14.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;118      */
;;;119    uint32_t CLK_GetHXTFreq(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;120    {
;;;121        uint32_t u32Freq;
;;;122    
;;;123        if((CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk) == CLK_PWRCTL_HXTEN_Msk)
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  f0100001          ANDS     r0,r0,#1
;;;124        {
;;;125            u32Freq = __HXT;
00000c  bf18              IT       NE
00000e  4801              LDRNE    r0,|L15.20|
;;;126        }
;;;127        else
;;;128        {
;;;129            u32Freq = 0UL;
;;;130        }
;;;131    
;;;132        return u32Freq;
;;;133    }
000010  4770              BX       lr
;;;134    
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=1

                  CLK_GetLXTFreq PROC
;;;141      */
;;;142    uint32_t CLK_GetLXTFreq(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;143    {
;;;144        uint32_t u32Freq;
;;;145        if((CLK->PWRCTL & CLK_PWRCTL_LXTEN_Msk) == CLK_PWRCTL_LXTEN_Msk)
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  f0100002          ANDS     r0,r0,#2
;;;146        {
;;;147            u32Freq = __LXT;
00000c  bf18              IT       NE
00000e  f44f4000          MOVNE    r0,#0x8000
;;;148        }
;;;149        else
;;;150        {
;;;151            u32Freq = 0UL;
;;;152        }
;;;153    
;;;154        return u32Freq;
;;;155    }
000012  4770              BX       lr
;;;156    
                          ENDP


                          AREA ||i.CLK_GetModuleClockDivider||, CODE, READONLY, ALIGN=2

                  CLK_GetModuleClockDivider PROC
;;;1219     */
;;;1220   uint32_t CLK_GetModuleClockDivider(uint32_t u32ModuleIdx)
000000  f8dfc03c          LDR      r12,|L17.64|
;;;1221   {
000004  b084              SUB      sp,sp,#0x10
;;;1222       uint32_t u32div = 0;
;;;1223       uint32_t u32DivTbl[4] = {0x0, 0x4, 0x8, 0x10};
;;;1224   
;;;1225       if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000006  f4103f7f          TST      r0,#0x3fc00
00000a  e89c100e          LDM      r12,{r1-r3,r12}       ;1223
00000e  e88d100e          STM      sp,{r1-r3,r12}        ;1223
;;;1226       {
;;;1227           /* Get clock divider control register address */
;;;1228           u32div = (uint32_t)&CLK->CLKDIV0 + (u32DivTbl[MODULE_CLKDIV(u32ModuleIdx)]);
;;;1229           /* Get clock divider number setting */
;;;1230           return ((M32(u32div) & (MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx))) >> MODULE_CLKDIV_Pos(u32ModuleIdx));
;;;1231       }
;;;1232       else
;;;1233           return 0;
000012  bf02              ITTT     EQ
000014  2000              MOVEQ    r0,#0
;;;1234   }
000016  b004              ADDEQ    sp,sp,#0x10
000018  4770              BXEQ     lr
00001a  f3c04281          UBFX     r2,r0,#18,#2          ;1228
00001e  f85d1022          LDR      r1,[sp,r2,LSL #2]     ;1228
000022  f1014180          ADD      r1,r1,#0x40000000     ;1228
000026  f5017108          ADD      r1,r1,#0x220          ;1228
00002a  6809              LDR      r1,[r1,#0]            ;1230
00002c  f3c02287          UBFX     r2,r0,#10,#8          ;1230
000030  f3c01044          UBFX     r0,r0,#5,#5           ;1230
000034  4082              LSLS     r2,r2,r0              ;1230
000036  4011              ANDS     r1,r1,r2              ;1230
000038  fa21f000          LSR      r0,r1,r0              ;1230
00003c  b004              ADD      sp,sp,#0x10
00003e  4770              BX       lr
;;;1235   
                          ENDP

                  |L17.64|
                          DCD      ||.constdata||+0x10

                          AREA ||i.CLK_GetModuleClockSource||, CODE, READONLY, ALIGN=2

                  CLK_GetModuleClockSource PROC
;;;1175     */
;;;1176   uint32_t CLK_GetModuleClockSource(uint32_t u32ModuleIdx)
000000  f8dfc088          LDR      r12,|L18.140|
;;;1177   {
000004  b084              SUB      sp,sp,#0x10
;;;1178       uint32_t u32sel = 0;
;;;1179       uint32_t u32SelTbl[4] = {0x0, 0x4, 0x8, 0xC};
000006  e89c100e          LDM      r12,{r1-r3,r12}
00000a  e88d100e          STM      sp,{r1-r3,r12}
;;;1180   
;;;1181       /* Get clock source selection setting */
;;;1182       if(u32ModuleIdx == EPWM0_MODULE)
00000e  4a20              LDR      r2,|L18.144|
;;;1183           return ((CLK->CLKSEL2 & CLK_CLKSEL2_EPWM0SEL_Msk) >> CLK_CLKSEL2_EPWM0SEL_Pos);
000010  0691              LSLS     r1,r2,#26
000012  4290              CMP      r0,r2                 ;1182
000014  bf01              ITTTT    EQ
000016  f8d10218          LDREQ    r0,[r1,#0x218]
00001a  f0000001          ANDEQ    r0,r0,#1
;;;1184       else if(u32ModuleIdx == EPWM1_MODULE)
;;;1185           return ((CLK->CLKSEL2 & CLK_CLKSEL2_EPWM1SEL_Msk) >> CLK_CLKSEL2_EPWM1SEL_Pos);
;;;1186       else if(u32ModuleIdx == BPWM0_MODULE)
;;;1187           return ((CLK->CLKSEL2 & CLK_CLKSEL2_BPWM0SEL_Msk) >> CLK_CLKSEL2_BPWM0SEL_Pos);
;;;1188       else if(u32ModuleIdx == BPWM1_MODULE)
;;;1189           return ((CLK->CLKSEL2 & CLK_CLKSEL2_BPWM1SEL_Msk) >> CLK_CLKSEL2_BPWM1SEL_Pos);
;;;1190       else if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
;;;1191       {
;;;1192           /* Get clock select control register address */
;;;1193           u32sel = (uint32_t)&CLK->CLKSEL0 + (u32SelTbl[MODULE_CLKSEL(u32ModuleIdx)]);
;;;1194           /* Get clock source selection setting */
;;;1195           return ((M32(u32sel) & (MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx))) >> MODULE_CLKSEL_Pos(u32ModuleIdx));
;;;1196       }
;;;1197       else
;;;1198           return 0;
;;;1199   }
00001e  b004              ADDEQ    sp,sp,#0x10
000020  4770              BXEQ     lr
000022  4a1c              LDR      r2,|L18.148|
000024  4290              CMP      r0,r2                 ;1184
000026  bf01              ITTTT    EQ                    ;1185
000028  f8d10218          LDREQ    r0,[r1,#0x218]        ;1185
00002c  f3c00040          UBFXEQ   r0,r0,#1,#1           ;1185
000030  b004              ADDEQ    sp,sp,#0x10
000032  4770              BXEQ     lr
000034  4a18              LDR      r2,|L18.152|
000036  4290              CMP      r0,r2                 ;1186
000038  bf01              ITTTT    EQ                    ;1187
00003a  f8d10218          LDREQ    r0,[r1,#0x218]        ;1187
00003e  f3c02000          UBFXEQ   r0,r0,#8,#1           ;1187
000042  b004              ADDEQ    sp,sp,#0x10
000044  4770              BXEQ     lr
000046  4a15              LDR      r2,|L18.156|
000048  4290              CMP      r0,r2                 ;1188
00004a  bf01              ITTTT    EQ                    ;1189
00004c  f8d10218          LDREQ    r0,[r1,#0x218]        ;1189
000050  f3c02040          UBFXEQ   r0,r0,#9,#1           ;1189
000054  b004              ADDEQ    sp,sp,#0x10
000056  4770              BXEQ     lr
000058  f0106f60          TST      r0,#0xe000000         ;1190
00005c  bf02              ITTT     EQ                    ;1198
00005e  2000              MOVEQ    r0,#0                 ;1198
000060  b004              ADDEQ    sp,sp,#0x10
000062  4770              BXEQ     lr
000064  f3c07201          UBFX     r2,r0,#28,#2          ;1193
000068  f85d1022          LDR      r1,[sp,r2,LSL #2]     ;1193
00006c  f1014180          ADD      r1,r1,#0x40000000     ;1193
000070  f5017104          ADD      r1,r1,#0x210          ;1193
000074  6809              LDR      r1,[r1,#0]            ;1195
000076  f3c06242          UBFX     r2,r0,#25,#3          ;1195
00007a  f3c05004          UBFX     r0,r0,#20,#5          ;1195
00007e  4082              LSLS     r2,r2,r0              ;1195
000080  4011              ANDS     r1,r1,r2              ;1195
000082  fa21f000          LSR      r0,r1,r0              ;1195
000086  b004              ADD      sp,sp,#0x10
000088  4770              BX       lr
;;;1200   
                          ENDP

00008a  0000              DCW      0x0000
                  |L18.140|
                          DCD      ||.constdata||
                  |L18.144|
                          DCD      0xa2000010
                  |L18.148|
                          DCD      0xa2100011
                  |L18.152|
                          DCD      0xa2800012
                  |L18.156|
                          DCD      0xa2900013

                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;162      */
;;;163    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;164    {
;;;165        uint32_t u32Freq;
;;;166        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;167    
;;;168    #if(1)
;;;169        if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_PCLK0DIV1)
000006  f04f4180          MOV      r1,#0x40000000
00000a  f8d10234          LDR      r0,[r1,#0x234]
00000e  f0100f07          TST      r0,#7
;;;170        {
;;;171            u32Freq = SystemCoreClock;
000012  4814              LDR      r0,|L19.100|
000014  d023              BEQ      |L19.94|
;;;172        }
;;;173        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_PCLK0DIV2)
000016  f8d12234          LDR      r2,[r1,#0x234]
00001a  f0020207          AND      r2,r2,#7
00001e  2a01              CMP      r2,#1
;;;174        {
;;;175            u32Freq = SystemCoreClock / 2UL;
000020  bf02              ITTT     EQ
000022  6800              LDREQ    r0,[r0,#0]  ; SystemCoreClock
000024  0840              LSREQ    r0,r0,#1
;;;176        }
;;;177        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_PCLK0DIV4)
;;;178        {
;;;179            u32Freq = SystemCoreClock / 4UL;
;;;180        }
;;;181        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_PCLK0DIV8)
;;;182        {
;;;183            u32Freq = SystemCoreClock / 8UL;
;;;184        }
;;;185        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_PCLK0DIV16)
;;;186        {
;;;187            u32Freq = SystemCoreClock / 16UL;
;;;188        }
;;;189        else
;;;190        {
;;;191            u32Freq = SystemCoreClock;
;;;192        }
;;;193    
;;;194    
;;;195    #else
;;;196        if((CLK->CLKSEL0 & CLK_CLKSEL0_PCLK0SEL_Msk) == CLK_CLKSEL0_PCLK0DIV1)
;;;197        {
;;;198            u32Freq =  SystemCoreClock;
;;;199        }
;;;200        else if((CLK->CLKSEL0 & CLK_CLKSEL0_PCLK0SEL_Msk) == CLK_CLKSEL0_PCLK0DIV2)
;;;201        {
;;;202            u32Freq =  SystemCoreClock / 2UL;
;;;203        }
;;;204        else
;;;205        {
;;;206            u32Freq =  SystemCoreClock;
;;;207        }
;;;208    #endif
;;;209    
;;;210        return u32Freq;
;;;211    }
000026  bd10              POPEQ    {r4,pc}
000028  f8d12234          LDR      r2,[r1,#0x234]        ;177
00002c  f0020207          AND      r2,r2,#7              ;177
000030  2a02              CMP      r2,#2                 ;177
000032  bf02              ITTT     EQ                    ;179
000034  6800              LDREQ    r0,[r0,#0]            ;179  ; SystemCoreClock
000036  0880              LSREQ    r0,r0,#2              ;179
000038  bd10              POPEQ    {r4,pc}
00003a  f8d12234          LDR      r2,[r1,#0x234]        ;181
00003e  f0020207          AND      r2,r2,#7              ;181
000042  2a03              CMP      r2,#3                 ;181
000044  bf02              ITTT     EQ                    ;183
000046  6800              LDREQ    r0,[r0,#0]            ;183  ; SystemCoreClock
000048  08c0              LSREQ    r0,r0,#3              ;183
00004a  bd10              POPEQ    {r4,pc}
00004c  f8d11234          LDR      r1,[r1,#0x234]        ;185
000050  f0010107          AND      r1,r1,#7              ;185
000054  2904              CMP      r1,#4                 ;185
000056  bf02              ITTT     EQ                    ;187
000058  6800              LDREQ    r0,[r0,#0]            ;187  ; SystemCoreClock
00005a  0900              LSREQ    r0,r0,#4              ;187
00005c  bd10              POPEQ    {r4,pc}
                  |L19.94|
00005e  6800              LDR      r0,[r0,#0]            ;171  ; SystemCoreClock
000060  bd10              POP      {r4,pc}
;;;212    
                          ENDP

000062  0000              DCW      0x0000
                  |L19.100|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;219      */
;;;220    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;221    {
;;;222        uint32_t u32Freq;
;;;223        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;224    
;;;225    #if(1)
;;;226        if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_PCLK1DIV1)
000006  f04f4180          MOV      r1,#0x40000000
00000a  f8d10234          LDR      r0,[r1,#0x234]
00000e  f0100f70          TST      r0,#0x70
;;;227        {
;;;228            u32Freq = SystemCoreClock;
000012  4814              LDR      r0,|L20.100|
000014  d023              BEQ      |L20.94|
;;;229        }
;;;230        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_PCLK1DIV2)
000016  f8d12234          LDR      r2,[r1,#0x234]
00001a  f0020270          AND      r2,r2,#0x70
00001e  2a10              CMP      r2,#0x10
;;;231        {
;;;232            u32Freq = SystemCoreClock / 2UL;
000020  bf02              ITTT     EQ
000022  6800              LDREQ    r0,[r0,#0]  ; SystemCoreClock
000024  0840              LSREQ    r0,r0,#1
;;;233        }
;;;234        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_PCLK1DIV4)
;;;235        {
;;;236            u32Freq = SystemCoreClock / 4UL;
;;;237        }
;;;238        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_PCLK1DIV8)
;;;239        {
;;;240            u32Freq = SystemCoreClock / 8UL;
;;;241        }
;;;242        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_PCLK1DIV16)
;;;243        {
;;;244            u32Freq = SystemCoreClock / 16UL;
;;;245        }
;;;246        else
;;;247        {
;;;248            u32Freq = SystemCoreClock;
;;;249        }
;;;250    
;;;251    
;;;252    #else
;;;253        if((CLK->CLKSEL0 & CLK_CLKSEL0_PCLK1SEL_Msk) == CLK_CLKSEL0_PCLK1DIV1)
;;;254        {
;;;255            u32Freq =  SystemCoreClock;
;;;256        }
;;;257        else if((CLK->CLKSEL0 & CLK_CLKSEL0_PCLK1SEL_Msk) == CLK_CLKSEL0_PCLK1DIV2)
;;;258        {
;;;259            u32Freq =  SystemCoreClock / 2UL;
;;;260        }
;;;261        else
;;;262        {
;;;263            u32Freq =  SystemCoreClock;
;;;264        }
;;;265    #endif
;;;266    
;;;267        return u32Freq;
;;;268    }
000026  bd10              POPEQ    {r4,pc}
000028  f8d12234          LDR      r2,[r1,#0x234]        ;234
00002c  f0020270          AND      r2,r2,#0x70           ;234
000030  2a20              CMP      r2,#0x20              ;234
000032  bf02              ITTT     EQ                    ;236
000034  6800              LDREQ    r0,[r0,#0]            ;236  ; SystemCoreClock
000036  0880              LSREQ    r0,r0,#2              ;236
000038  bd10              POPEQ    {r4,pc}
00003a  f8d12234          LDR      r2,[r1,#0x234]        ;238
00003e  f0020270          AND      r2,r2,#0x70           ;238
000042  2a30              CMP      r2,#0x30              ;238
000044  bf02              ITTT     EQ                    ;240
000046  6800              LDREQ    r0,[r0,#0]            ;240  ; SystemCoreClock
000048  08c0              LSREQ    r0,r0,#3              ;240
00004a  bd10              POPEQ    {r4,pc}
00004c  f8d11234          LDR      r1,[r1,#0x234]        ;242
000050  f0010170          AND      r1,r1,#0x70           ;242
000054  2940              CMP      r1,#0x40              ;242
000056  bf02              ITTT     EQ                    ;244
000058  6800              LDREQ    r0,[r0,#0]            ;244  ; SystemCoreClock
00005a  0900              LSREQ    r0,r0,#4              ;244
00005c  bd10              POPEQ    {r4,pc}
                  |L20.94|
00005e  6800              LDR      r0,[r0,#0]            ;228  ; SystemCoreClock
000060  bd10              POP      {r4,pc}
;;;269    
                          ENDP

000062  0000              DCW      0x0000
                  |L20.100|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;1093     */
;;;1094   uint32_t CLK_GetPLLClockFreq(void)
000000  a113              ADR      r1,|L21.80|
;;;1095   {
000002  b081              SUB      sp,sp,#4
;;;1096       uint32_t u32PllFreq = 0UL, u32PllReg;
;;;1097       uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;1098       uint8_t au8NoTbl[4] = {1U, 2U, 2U, 4U};
000004  6809              LDR      r1,[r1,#0]
;;;1099   
;;;1100       u32PllReg = CLK->PLLCTL;
000006  9100              STR      r1,[sp,#0]
000008  f04f4180          MOV      r1,#0x40000000
00000c  2000              MOVS     r0,#0                 ;1096
00000e  f8d11240          LDR      r1,[r1,#0x240]
;;;1101   
;;;1102       if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
000012  f4112fa0          TST      r1,#0x50000
;;;1103       {
;;;1104           u32PllFreq = 0UL;           /* PLL is in power down mode or fix low */
;;;1105       }
;;;1106       else if((u32PllReg & CLK_PLLCTL_BP_Msk) == CLK_PLLCTL_BP_Msk)
;;;1107       {
;;;1108           if((u32PllReg & CLK_PLLCTL_PLLSRC_HIRC) == CLK_PLLCTL_PLLSRC_HIRC)
;;;1109           {
;;;1110               u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;1111           }
;;;1112           else
;;;1113           {
;;;1114               u32FIN = __HXT;     /* PLL source clock from HXT */
;;;1115           }
;;;1116   
;;;1117           u32PllFreq = u32FIN;
;;;1118       }
;;;1119       else
;;;1120       {
;;;1121           if((u32PllReg & CLK_PLLCTL_PLLSRC_HIRC) == CLK_PLLCTL_PLLSRC_HIRC)
;;;1122           {
;;;1123               u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;1124           }
;;;1125           else
;;;1126           {
;;;1127               u32FIN = __HXT;     /* PLL source clock from HXT */
;;;1128           }
;;;1129           /* PLL is output enabled in normal work mode */
;;;1130           u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;1131           u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2UL;
;;;1132           u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 1UL;
;;;1133   
;;;1134           /* u32FIN is shifted 2 bits to avoid overflow */
;;;1135           u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2) * 2UL;
;;;1136       }
;;;1137   
;;;1138       return u32PllFreq;
;;;1139   }
000016  bf1c              ITT      NE
000018  b001              ADDNE    sp,sp,#4
00001a  4770              BXNE     lr
00001c  f4113f00          TST      r1,#0x20000           ;1106
000020  480c              LDR      r0,|L21.84|
000022  bf1c              ITT      NE
000024  b001              ADDNE    sp,sp,#4
000026  4770              BXNE     lr
000028  f3c13281          UBFX     r2,r1,#14,#2          ;1130
00002c  f3c10008          UBFX     r0,r1,#0,#9           ;1131
000030  1c80              ADDS     r0,r0,#2              ;1135
000032  4b09              LDR      r3,|L21.88|
000034  f81d2002          LDRB     r2,[sp,r2]            ;1130
000038  f3c12144          UBFX     r1,r1,#9,#5           ;1132
00003c  4358              MULS     r0,r3,r0              ;1135
00003e  1c49              ADDS     r1,r1,#1              ;1135
000040  fb11f102          SMULBB   r1,r1,r2              ;1135
000044  fbb0f0f1          UDIV     r0,r0,r1              ;1135
000048  00c0              LSLS     r0,r0,#3              ;1135
00004a  b001              ADD      sp,sp,#4
00004c  4770              BX       lr
;;;1140   
                          ENDP

00004e  0000              DCW      0x0000
                  |L21.80|
000050  01020204          DCB      1,2,2,4
                  |L21.84|
                          DCD      0x00b71b00
                  |L21.88|
                          DCD      0x002dc6c0

                          AREA ||i.CLK_GetPMUWKSrc||, CODE, READONLY, ALIGN=1

                  CLK_GetPMUWKSrc PROC
;;;1051   
;;;1052   uint32_t CLK_GetPMUWKSrc(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;1053   {
;;;1054       return (CLK->PMUSTS);
000004  f8d00294          LDR      r0,[r0,#0x294]
;;;1055   }
000008  4770              BX       lr
;;;1056   
                          ENDP


                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;100      */
;;;101    void CLK_Idle(void)
000000  4806              LDR      r0,|L23.28|
;;;102    {
;;;103        /* Set the processor uses sleep as its low power mode */
;;;104        SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6801              LDR      r1,[r0,#0]
000004  f0210104          BIC      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;105    
;;;106        /* Set chip in idle mode because of WFI command */
;;;107        CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
000010  f0210180          BIC      r1,r1,#0x80
000014  f8c01200          STR      r1,[r0,#0x200]
;;;108    
;;;109        /* Chip enter idle mode after CPU run WFI instruction */
;;;110        __WFI();
000018  bf30              WFI      
;;;111    }
00001a  4770              BX       lr
;;;112    
                          ENDP

                  |L23.28|
                          DCD      0xe000ed10

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;70       */
;;;71     void CLK_PowerDown(void)
000000  480a              LDR      r0,|L24.44|
;;;72     {
;;;73         uint32_t u32HIRCTRIMCTL;
;;;74     
;;;75         /* Set the processor uses deep sleep as its low power mode */
;;;76         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;77     
;;;78         /* Set system Power-down enabled */
;;;79         CLK->PWRCTL |= (CLK_PWRCTL_PDEN_Msk);
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
000010  f0410180          ORR      r1,r1,#0x80
000014  f8c01200          STR      r1,[r0,#0x200]
;;;80     
;;;81         /* Store HIRC control register */
;;;82         u32HIRCTRIMCTL = SYS->IRCTCTL;
000018  f8501ff0          LDR      r1,[r0,#0xf0]!
;;;83     
;;;84         /* Disable HIRC auto trim */
;;;85         SYS->IRCTCTL &= (~SYS_IRCTCTL_FREQSEL_Msk);
00001c  6802              LDR      r2,[r0,#0]
00001e  f0220203          BIC      r2,r2,#3
000022  6002              STR      r2,[r0,#0]
;;;86     
;;;87         /* Chip enter Power-down mode after CPU run WFI instruction */
;;;88         __WFI();
000024  bf30              WFI      
;;;89     
;;;90         /* Restore HIRC control register */
;;;91         SYS->IRCTCTL = u32HIRCTRIMCTL;
000026  6001              STR      r1,[r0,#0]
;;;92     }
000028  4770              BX       lr
;;;93     
                          ENDP

00002a  0000              DCW      0x0000
                  |L24.44|
                          DCD      0xe000ed10

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;303      */
;;;304    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;305    {
;;;306        uint32_t u32HIRCSTB;
;;;307    
;;;308        /* Read HIRC clock source stable flag */
;;;309        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000004  f04f4580          MOV      r5,#0x40000000
000008  f8d51250          LDR      r1,[r5,#0x250]
00000c  f0010610          AND      r6,r1,#0x10
;;;310    
;;;311        /* The range of u32Hclk is running up to 192 MHz */
;;;312        if(u32Hclk > FREQ_192MHZ)
000010  493f              LDR      r1,|L25.272|
000012  4288              CMP      r0,r1
;;;313        {
;;;314            u32Hclk = FREQ_192MHZ;
000014  bf88              IT       HI
000016  4608              MOVHI    r0,r1
;;;315        }
;;;316    
;;;317        /* Switch HCLK clock source to HIRC clock for safe */
;;;318        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000018  f8d51200          LDR      r1,[r5,#0x200]
00001c  f0410104          ORR      r1,r1,#4
000020  f8c51200          STR      r1,[r5,#0x200]
000024  f8d51250          LDR      r1,[r5,#0x250]
;;;319        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000028  2210              MOVS     r2,#0x10
00002a  4c3a              LDR      r4,|L25.276|
00002c  ea320101          BICS     r1,r2,r1
000030  bf18              IT       NE
000032  4623              MOVNE    r3,r4
000034  d009              BEQ      |L25.74|
000036  bf00              NOP                            ;305
                  |L25.56|
000038  f8d5c250          LDR      r12,[r5,#0x250]       ;305
00003c  ea320c0c          BICS     r12,r2,r12            ;305
000040  d003              BEQ      |L25.74|
000042  1e19              SUBS     r1,r3,#0              ;305
000044  f1a30301          SUB      r3,r3,#1              ;305
000048  dcf6              BGT      |L25.56|
                  |L25.74|
;;;320        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
00004a  f8d51210          LDR      r1,[r5,#0x210]
00004e  f0410107          ORR      r1,r1,#7
000052  f8c51210          STR      r1,[r5,#0x210]
;;;321        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
000056  f8d51220          LDR      r1,[r5,#0x220]
00005a  f021010f          BIC      r1,r1,#0xf
00005e  f8c51220          STR      r1,[r5,#0x220]
;;;322    
;;;323        /* Configure PLL setting if HXT clock is enabled */
;;;324        if((CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk) == CLK_PWRCTL_HXTEN_Msk)
000062  f8d51200          LDR      r1,[r5,#0x200]
000066  f0110f01          TST      r1,#1
;;;325        {
;;;326            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, u32Hclk);
;;;327        }
;;;328        /* Configure PLL setting if HXT clock is not enabled */
;;;329        else
;;;330        {
;;;331            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC, u32Hclk);
00006a  4601              MOV      r1,r0
00006c  d004              BEQ      |L25.120|
00006e  2000              MOVS     r0,#0                 ;326
000070  f7fffffe          BL       CLK_EnablePLL
000074  4680              MOV      r8,r0                 ;326
000076  e008              B        |L25.138|
                  |L25.120|
000078  f44f2000          MOV      r0,#0x80000
00007c  f7fffffe          BL       CLK_EnablePLL
000080  4680              MOV      r8,r0
;;;332    
;;;333            /* Read HIRC clock source stable flag */
;;;334            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000082  f8d50250          LDR      r0,[r5,#0x250]
000086  f0000610          AND      r6,r0,#0x10
                  |L25.138|
;;;335        }
;;;336    
;;;337        /* Select HCLK clock source to PLL,
;;;338           and update system core clock
;;;339        */
;;;340        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(1UL));
00008a  2102              MOVS     r1,#2
00008c  f8d50250          LDR      r0,[r5,#0x250]
000090  2300              MOVS     r3,#0
000092  f0000710          AND      r7,r0,#0x10
000096  f8d50200          LDR      r0,[r5,#0x200]
00009a  f0400004          ORR      r0,r0,#4
00009e  f8c50200          STR      r0,[r5,#0x200]
0000a2  f8d52250          LDR      r2,[r5,#0x250]
0000a6  2010              MOVS     r0,#0x10
0000a8  ea300202          BICS     r2,r0,r2
0000ac  d009              BEQ      |L25.194|
0000ae  e003              B        |L25.184|
                  |L25.176|
0000b0  1e22              SUBS     r2,r4,#0
0000b2  f1a40401          SUB      r4,r4,#1
0000b6  dd04              BLE      |L25.194|
                  |L25.184|
0000b8  f8d52250          LDR      r2,[r5,#0x250]
0000bc  ea300202          BICS     r2,r0,r2
0000c0  d1f6              BNE      |L25.176|
                  |L25.194|
0000c2  f8d50210          LDR      r0,[r5,#0x210]
0000c6  f0400007          ORR      r0,r0,#7
0000ca  f8c50210          STR      r0,[r5,#0x210]
0000ce  f8d50220          LDR      r0,[r5,#0x220]
0000d2  f020000f          BIC      r0,r0,#0xf
0000d6  4318              ORRS     r0,r0,r3
0000d8  f8c50220          STR      r0,[r5,#0x220]
0000dc  f8d50210          LDR      r0,[r5,#0x210]
0000e0  f0200007          BIC      r0,r0,#7
0000e4  4308              ORRS     r0,r0,r1
0000e6  f8c50210          STR      r0,[r5,#0x210]
0000ea  f7fffffe          BL       SystemCoreClockUpdate
0000ee  b92f              CBNZ     r7,|L25.252|
0000f0  f8d50200          LDR      r0,[r5,#0x200]
0000f4  f0200004          BIC      r0,r0,#4
0000f8  f8c50200          STR      r0,[r5,#0x200]
                  |L25.252|
;;;341    
;;;342        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;343        if(u32HIRCSTB == 0UL)
0000fc  b92e              CBNZ     r6,|L25.266|
;;;344        {
;;;345            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
0000fe  f8d50200          LDR      r0,[r5,#0x200]
000102  f0200004          BIC      r0,r0,#4
000106  f8c50200          STR      r0,[r5,#0x200]
                  |L25.266|
;;;346        }
;;;347    
;;;348        /* Return actually HCLK frequency is PLL frequency divide 1 */
;;;349        return u32Hclk;
00010a  4640              MOV      r0,r8
;;;350    }
00010c  e8bd81f0          POP      {r4-r8,pc}
;;;351    
                          ENDP

                  |L25.272|
                          DCD      0x0b71b000
                  |L25.276|
                          DCD      0x0020f57f

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=2

                  CLK_SetHCLK PROC
;;;365      */
;;;366    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b570              PUSH     {r4-r6,lr}
;;;367    {
;;;368        uint32_t u32HIRCSTB;
;;;369    
;;;370        /* Read HIRC clock source stable flag */
;;;371        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000002  f04f4480          MOV      r4,#0x40000000
000006  f8d42250          LDR      r2,[r4,#0x250]
00000a  f0020510          AND      r5,r2,#0x10
;;;372    
;;;373        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;374        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00000e  f8d42200          LDR      r2,[r4,#0x200]
000012  f0420204          ORR      r2,r2,#4
000016  f8c42200          STR      r2,[r4,#0x200]
00001a  f8d42250          LDR      r2,[r4,#0x250]
;;;375        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001e  2310              MOVS     r3,#0x10
000020  ea330202          BICS     r2,r3,r2
000024  bf18              IT       NE
000026  4a16              LDRNE    r2,|L26.128|
000028  d00a              BEQ      |L26.64|
00002a  bf00              NOP                            ;367
                  |L26.44|
00002c  f8d4c250          LDR      r12,[r4,#0x250]       ;367
000030  ea330c0c          BICS     r12,r3,r12            ;367
000034  d004              BEQ      |L26.64|
000036  f1b20c00          SUBS     r12,r2,#0             ;367
00003a  f1a20201          SUB      r2,r2,#1              ;367
00003e  dcf5              BGT      |L26.44|
                  |L26.64|
;;;376        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
000040  f8d42210          LDR      r2,[r4,#0x210]
000044  f0420207          ORR      r2,r2,#7
000048  f8c42210          STR      r2,[r4,#0x210]
;;;377    
;;;378        /* Apply new Divider */
;;;379        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
00004c  f8d42220          LDR      r2,[r4,#0x220]
000050  f022020f          BIC      r2,r2,#0xf
000054  4311              ORRS     r1,r1,r2
000056  f8c41220          STR      r1,[r4,#0x220]
;;;380    
;;;381        /* Switch HCLK to new HCLK source */
;;;382        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
00005a  f8d41210          LDR      r1,[r4,#0x210]
00005e  f0210107          BIC      r1,r1,#7
000062  4308              ORRS     r0,r0,r1
000064  f8c40210          STR      r0,[r4,#0x210]
;;;383    
;;;384        /* Update System Core Clock */
;;;385        SystemCoreClockUpdate();
000068  f7fffffe          BL       SystemCoreClockUpdate
;;;386    
;;;387        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;388        if(u32HIRCSTB == 0UL)
00006c  2d00              CMP      r5,#0
;;;389        {
;;;390            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
;;;391        }
;;;392    }
00006e  bf18              IT       NE
000070  bd70              POPNE    {r4-r6,pc}
000072  f8d40200          LDR      r0,[r4,#0x200]        ;390
000076  f0200004          BIC      r0,r0,#4              ;390
00007a  f8c40200          STR      r0,[r4,#0x200]        ;390
00007e  bd70              POP      {r4-r6,pc}
;;;393    
                          ENDP

                  |L26.128|
                          DCD      0x0020f57f

                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;517      */
;;;518    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b430              PUSH     {r4,r5}
;;;519    {
;;;520        uint32_t u32sel = 0U, u32div = 0U;
;;;521    
;;;522        if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000002  f4103f7f          TST      r0,#0x3fc00
000006  d01b              BEQ      |L27.64|
;;;523        {
;;;524            /* Get clock divider control register address */
;;;525            if(MODULE_CLKDIV(u32ModuleIdx) == 2U)
000008  f3c04381          UBFX     r3,r0,#18,#2
00000c  2b02              CMP      r3,#2
;;;526            {
;;;527                u32div = (uint32_t)&CLK->CLKDIV3;
00000e  bf08              IT       EQ
000010  4b17              LDREQ    r3,|L27.112|
000012  d009              BEQ      |L27.40|
;;;528            }
;;;529            else if (MODULE_CLKDIV(u32ModuleIdx) == 3U)
000014  f04f0c03          MOV      r12,#3
000018  ea3c4c90          BICS     r12,r12,r0,LSR #18
;;;530            {
;;;531                u32div = (uint32_t)&CLK->CLKDIV4;
00001c  bf0e              ITEE     EQ
00001e  4b15              LDREQ    r3,|L27.116|
;;;532            }
;;;533            else
;;;534            {
;;;535                u32div = (uint32_t)&CLK->CLKDIV0 + ((MODULE_CLKDIV(u32ModuleIdx)) * 4U);
000020  f8dfc054          LDRNE    r12,|L27.120|
000024  eb0c0383          ADDNE    r3,r12,r3,LSL #2
                  |L27.40|
;;;536            }
;;;537    
;;;538            /* Apply new divider */
;;;539            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
000028  f8d3c000          LDR      r12,[r3,#0]
00002c  f3c02487          UBFX     r4,r0,#10,#8
000030  f3c01544          UBFX     r5,r0,#5,#5
000034  40ac              LSLS     r4,r4,r5
000036  ea2c0c04          BIC      r12,r12,r4
00003a  ea4c0202          ORR      r2,r12,r2
00003e  601a              STR      r2,[r3,#0]
                  |L27.64|
;;;540        }
;;;541    
;;;542        if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
000040  f0106f60          TST      r0,#0xe000000
;;;543        {
;;;544            /* Get clock select control register address */
;;;545            u32sel = (uint32_t)&CLK->CLKSEL0 + ((MODULE_CLKSEL(u32ModuleIdx)) * 4U);
;;;546            /* Set new clock selection setting */
;;;547            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
;;;548        }
;;;549    }
000044  bf04              ITT      EQ
000046  bc30              POPEQ    {r4,r5}
000048  4770              BXEQ     lr
00004a  f3c07201          UBFX     r2,r0,#28,#2          ;545
00004e  4b0b              LDR      r3,|L27.124|
000050  eb030282          ADD      r2,r3,r2,LSL #2       ;545
000054  6813              LDR      r3,[r2,#0]            ;547
000056  f3c06c42          UBFX     r12,r0,#25,#3         ;547
00005a  f3c05004          UBFX     r0,r0,#20,#5          ;547
00005e  fa0cf000          LSL      r0,r12,r0             ;547
000062  ea230000          BIC      r0,r3,r0              ;547
000066  4308              ORRS     r0,r0,r1              ;547
000068  6010              STR      r0,[r2,#0]            ;547
00006a  bc30              POP      {r4,r5}
00006c  4770              BX       lr
;;;550    
                          ENDP

00006e  0000              DCW      0x0000
                  |L27.112|
                          DCD      0x4000022c
                  |L27.116|
                          DCD      0x40000230
                  |L27.120|
                          DCD      0x40000220
                  |L27.124|
                          DCD      0x40000210

                          AREA ||i.CLK_SetPowerDownMode||, CODE, READONLY, ALIGN=2

                  CLK_SetPowerDownMode PROC
;;;1010   
;;;1011   void CLK_SetPowerDownMode(uint32_t u32PDMode)
000000  f04f4180          MOV      r1,#0x40000000
;;;1012   {
;;;1013       /* Enable LIRC clock before entering to Standby Power-down Mode */
;;;1014       if((u32PDMode == CLK_PMUCTL_PDMSEL_SPD0) || (u32PDMode == CLK_PMUCTL_PDMSEL_SPD1))
000004  2804              CMP      r0,#4
000006  bf18              IT       NE
000008  2805              CMPNE    r0,#5
00000a  d119              BNE      |L28.64|
;;;1015       {
;;;1016           /* Enable LIRC clock */
;;;1017           CLK->PWRCTL |= CLK_PWRCTL_LIRCEN_Msk;
00000c  f8d12200          LDR      r2,[r1,#0x200]
000010  f0420208          ORR      r2,r2,#8
000014  f8c12200          STR      r2,[r1,#0x200]
000018  f8d13250          LDR      r3,[r1,#0x250]
;;;1018   
;;;1019           /* Wait for LIRC clock stable */
;;;1020           CLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);
00001c  f04f0208          MOV      r2,#8
000020  ea320303          BICS     r3,r2,r3
000024  bf18              IT       NE
000026  4b0a              LDRNE    r3,|L28.80|
000028  d00a              BEQ      |L28.64|
00002a  bf00              NOP      
                  |L28.44|
00002c  f8d1c250          LDR      r12,[r1,#0x250]
000030  ea320c0c          BICS     r12,r2,r12
000034  d004              BEQ      |L28.64|
000036  f1b30c00          SUBS     r12,r3,#0
00003a  f1a30301          SUB      r3,r3,#1
00003e  dcf5              BGT      |L28.44|
                  |L28.64|
;;;1021       }
;;;1022   
;;;1023       CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_PDMSEL_Msk)) | u32PDMode;
000040  f8d12290          LDR      r2,[r1,#0x290]
000044  f0220207          BIC      r2,r2,#7
000048  4310              ORRS     r0,r0,r2
00004a  f8c10290          STR      r0,[r1,#0x290]
;;;1024   }
00004e  4770              BX       lr
;;;1025   
                          ENDP

                  |L28.80|
                          DCD      0x0020f57f

                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=1

                  CLK_SetSysTickClockSrc PROC
;;;562      */
;;;563    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  f04f4180          MOV      r1,#0x40000000
;;;564    {
;;;565        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000004  f8d12210          LDR      r2,[r1,#0x210]
000008  f0220238          BIC      r2,r2,#0x38
00000c  4310              ORRS     r0,r0,r2
00000e  f8c10210          STR      r0,[r1,#0x210]
;;;566    
;;;567    }
000012  4770              BX       lr
;;;568    
                          ENDP


                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;928      */
;;;929    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  f04f4380          MOV      r3,#0x40000000
;;;930    {
;;;931        int32_t i32TimeOutCnt = 2160000;
;;;932        uint32_t u32Ret = 1U;
000004  f04f0c01          MOV      r12,#1
;;;933    
;;;934        while((CLK->STATUS & u32ClkMask) != u32ClkMask)
000008  f8d31250          LDR      r1,[r3,#0x250]
00000c  ea300101          BICS     r1,r0,r1
;;;935        {
;;;936            if(i32TimeOutCnt-- <= 0)
000010  bf18              IT       NE
000012  4908              LDRNE    r1,|L30.52|
000014  d00c              BEQ      |L30.48|
000016  e006              B        |L30.38|
                  |L30.24|
000018  1e0a              SUBS     r2,r1,#0
00001a  f1a10101          SUB      r1,r1,#1
00001e  dc02              BGT      |L30.38|
;;;937            {
;;;938                u32Ret = 0U;
000020  f04f0c00          MOV      r12,#0
;;;939                break;
000024  e004              B        |L30.48|
                  |L30.38|
000026  f8d32250          LDR      r2,[r3,#0x250]        ;934
00002a  ea300202          BICS     r2,r0,r2              ;934
00002e  d1f3              BNE      |L30.24|
                  |L30.48|
;;;940            }
;;;941        }
;;;942        return u32Ret;
000030  4660              MOV      r0,r12
;;;943    }
000032  4770              BX       lr
;;;944    
                          ENDP

                  |L30.52|
                          DCD      0x0020f57f

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x0000000c
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000010

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 402
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____RRX|
#line 587
|__asm___5_clk_c_9b5832dc____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
