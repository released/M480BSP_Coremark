; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\core_list_join.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\core_list_join.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -I..\Coremark -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DMAIN_HAS_NOARGC --omf_browse=.\obj\core_list_join.crf ..\Coremark\core_list_join.c]
                          THUMB

                          AREA ||i.calc_func||, CODE, READONLY, ALIGN=1

                  calc_func PROC
;;;61     
;;;62     ee_s16 calc_func(ee_s16 *pdata, core_results *res) {
000000  b5f0              PUSH     {r4-r7,lr}
;;;63     	ee_s16 data=*pdata;
000002  f9b06000          LDRSH    r6,[r0,#0]
000006  4607              MOV      r7,r0                 ;62
;;;64     	ee_s16 retval;
;;;65     	ee_u8 optype=(data>>7) & 1; /* bit 7 indicates if the function result has been cached */
000008  f3c610c0          UBFX     r0,r6,#7,#1
00000c  b083              SUB      sp,sp,#0xc            ;62
00000e  460c              MOV      r4,r1                 ;62
;;;66     	if (optype) /* if cached, use cache */
000010  2800              CMP      r0,#0
;;;67     		return (data & 0x007f);
000012  bf1e              ITTT     NE
000014  f006007f          ANDNE    r0,r6,#0x7f
;;;68     	else { /* otherwise calculate and cache the result */
;;;69     		ee_s16 flag=data & 0x7; /* bits 0-2 is type of function to perform */
;;;70     		ee_s16 dtype=((data>>3) & 0xf); /* bits 3-6 is specific data for the operation */
;;;71     		dtype |= dtype << 4; /* replicate the lower 4 bits to get an 8b value */
;;;72     		switch (flag) {
;;;73     			case 0:
;;;74     				if (dtype<0x22) /* set min period for bit corruption */
;;;75     					dtype=0x22;
;;;76     				retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
;;;77     				if (res->crcstate==0)
;;;78     					res->crcstate=retval;
;;;79     				break;
;;;80     			case 1:
;;;81     				retval=core_bench_matrix(&(res->mat),dtype,res->crc);
;;;82     				if (res->crcmatrix==0)
;;;83     					res->crcmatrix=retval;
;;;84     				break;
;;;85     			default:
;;;86     				retval=data;
;;;87     				break;
;;;88     		}
;;;89     		res->crc=crcu16(retval,res->crc);
;;;90     		retval &= 0x007f; 
;;;91     		*pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
;;;92     		return retval;
;;;93     	}
;;;94     }
000018  b003              ADDNE    sp,sp,#0xc
00001a  bdf0              POPNE    {r4-r7,pc}
00001c  f0160007          ANDS     r0,r6,#7              ;69
000020  f3c601c3          UBFX     r1,r6,#3,#4           ;70
000024  ea411101          ORR      r1,r1,r1,LSL #4       ;71
000028  d012              BEQ      |L1.80|
00002a  2801              CMP      r0,#1                 ;72
00002c  bf18              IT       NE                    ;86
00002e  4635              MOVNE    r5,r6                 ;86
000030  d022              BEQ      |L1.120|
                  |L1.50|
000032  8f21              LDRH     r1,[r4,#0x38]         ;89
000034  b2a8              UXTH     r0,r5                 ;89
000036  f7fffffe          BL       crcu16
00003a  8720              STRH     r0,[r4,#0x38]         ;89
00003c  f005007f          AND      r0,r5,#0x7f           ;90
000040  f406417f          AND      r1,r6,#0xff00         ;91
000044  4301              ORRS     r1,r1,r0              ;91
000046  f0410180          ORR      r1,r1,#0x80           ;91
00004a  8039              STRH     r1,[r7,#0]            ;91
00004c  b003              ADD      sp,sp,#0xc
00004e  bdf0              POP      {r4-r7,pc}
                  |L1.80|
000050  2922              CMP      r1,#0x22              ;74
000052  bfb8              IT       LT                    ;75
000054  2122              MOVLT    r1,#0x22              ;75
000056  8f20              LDRH     r0,[r4,#0x38]         ;76
000058  e9cd1000          STRD     r1,r0,[sp,#0]         ;76
00005c  e9d41005          LDRD     r1,r0,[r4,#0x14]      ;76
000060  f9b43002          LDRSH    r3,[r4,#2]            ;76
000064  f9b42000          LDRSH    r2,[r4,#0]            ;76
000068  f7fffffe          BL       core_bench_state
00006c  b205              SXTH     r5,r0                 ;76
00006e  8fe0              LDRH     r0,[r4,#0x3e]         ;77
000070  2800              CMP      r0,#0                 ;77
000072  bf08              IT       EQ                    ;78
000074  87e5              STRHEQ   r5,[r4,#0x3e]         ;78
000076  e7dc              B        |L1.50|
                  |L1.120|
000078  8f22              LDRH     r2,[r4,#0x38]         ;81
00007a  f1040028          ADD      r0,r4,#0x28           ;81
00007e  f7fffffe          BL       core_bench_matrix
000082  b205              SXTH     r5,r0                 ;81
000084  8fa0              LDRH     r0,[r4,#0x3c]         ;82
000086  2800              CMP      r0,#0                 ;82
000088  bf08              IT       EQ                    ;83
00008a  87a5              STRHEQ   r5,[r4,#0x3c]         ;83
00008c  e7d1              B        |L1.50|
;;;95     /* Function: cmp_complex
                          ENDP


                          AREA ||i.cmp_complex||, CODE, READONLY, ALIGN=1

                  cmp_complex PROC
;;;99     */
;;;100    ee_s32 cmp_complex(list_data *a, list_data *b, core_results *res) {
000000  b570              PUSH     {r4-r6,lr}
000002  460e              MOV      r6,r1
000004  4615              MOV      r5,r2
;;;101    	ee_s16 val1=calc_func(&(a->data16),res);
000006  4611              MOV      r1,r2
000008  f7fffffe          BL       calc_func
00000c  4604              MOV      r4,r0
;;;102    	ee_s16 val2=calc_func(&(b->data16),res);
00000e  4629              MOV      r1,r5
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       calc_func
;;;103    	return val1 - val2;
000016  1a20              SUBS     r0,r4,r0
;;;104    }
000018  bd70              POP      {r4-r6,pc}
;;;105    
                          ENDP


                          AREA ||i.cmp_idx||, CODE, READONLY, ALIGN=1

                  cmp_idx PROC
;;;110    */
;;;111    ee_s32 cmp_idx(list_data *a, list_data *b, core_results *res) {
000000  b96a              CBNZ     r2,|L3.30|
;;;112    	if (res==NULL) {
;;;113    		a->data16 = (a->data16 & 0xff00) | (0x00ff & (a->data16>>8));
000002  8802              LDRH     r2,[r0,#0]
000004  f402437f          AND      r3,r2,#0xff00
000008  f3c22207          UBFX     r2,r2,#8,#8
00000c  431a              ORRS     r2,r2,r3
00000e  8002              STRH     r2,[r0,#0]
;;;114    		b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
000010  880a              LDRH     r2,[r1,#0]
000012  f402437f          AND      r3,r2,#0xff00
000016  f3c22207          UBFX     r2,r2,#8,#8
00001a  431a              ORRS     r2,r2,r3
00001c  800a              STRH     r2,[r1,#0]
                  |L3.30|
;;;115    	}
;;;116    	return a->idx - b->idx;
00001e  f9b00002          LDRSH    r0,[r0,#2]
000022  f9b11002          LDRSH    r1,[r1,#2]
000026  1a40              SUBS     r0,r0,r1
;;;117    }
000028  4770              BX       lr
;;;118    
                          ENDP


                          AREA ||i.copy_info||, CODE, READONLY, ALIGN=1

                  copy_info PROC
;;;118    
;;;119    void copy_info(list_data *to,list_data *from) {
000000  880a              LDRH     r2,[r1,#0]
;;;120    	to->data16=from->data16;
000002  8002              STRH     r2,[r0,#0]
;;;121    	to->idx=from->idx;
000004  8849              LDRH     r1,[r1,#2]
000006  8041              STRH     r1,[r0,#2]
;;;122    }
000008  4770              BX       lr
;;;123    
                          ENDP


                          AREA ||i.core_bench_list||, CODE, READONLY, ALIGN=2

                  core_bench_list PROC
;;;130    */
;;;131    ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;132    	ee_u16 retval=0;
000004  2300              MOVS     r3,#0
;;;133    	ee_u16 found=0,missed=0;
;;;134    	list_head *list=res->list;
;;;135    	ee_s16 find_num=res->seed3;
000006  f9b0a004          LDRSH    r10,[r0,#4]
00000a  4689              MOV      r9,r1                 ;131
;;;136    	list_head *this_find;
;;;137    	list_head *finder, *remover;
;;;138    	list_data info;
;;;139    	ee_s16 i;
;;;140    
;;;141    	info.idx=finder_idx;
;;;142    	/* find <find_num> values in the list, and change the list each time (reverse and cache if value found) */
;;;143    	for (i=0; i<find_num; i++) {
00000c  6a45              LDR      r5,[r0,#0x24]
00000e  4602              MOV      r2,r0                 ;131
000010  4698              MOV      r8,r3                 ;133
000012  461f              MOV      r7,r3                 ;133
000014  f369461f          BFI      r6,r9,#16,#16         ;135
000018  469c              MOV      r12,r3
00001a  f1ba0f00          CMP      r10,#0
00001e  dd47              BLE      |L5.176|
                  |L5.32|
;;;144    		info.data16= (i & 0xff) ;
000020  f00c00ff          AND      r0,r12,#0xff
000024  f360060f          BFI      r6,r0,#0,#16
;;;145    		this_find=core_list_find(list,&info);
000028  462c              MOV      r4,r5
00002a  1431              ASRS     r1,r6,#16
00002c  d408              BMI      |L5.64|
                  |L5.46|
00002e  b184              CBZ      r4,|L5.82|
000030  6860              LDR      r0,[r4,#4]
000032  f9b00002          LDRSH    r0,[r0,#2]
000036  4288              CMP      r0,r1
000038  bf18              IT       NE
00003a  6824              LDRNE    r4,[r4,#0]
00003c  d1f7              BNE      |L5.46|
00003e  e008              B        |L5.82|
                  |L5.64|
000040  b13c              CBZ      r4,|L5.82|
000042  f8d4b004          LDR      r11,[r4,#4]
000046  f89bb000          LDRB     r11,[r11,#0]
00004a  4583              CMP      r11,r0
00004c  bf18              IT       NE
00004e  6824              LDRNE    r4,[r4,#0]
000050  d1f6              BNE      |L5.64|
                  |L5.82|
000052  2000              MOVS     r0,#0
000054  b13d              CBZ      r5,|L5.102|
000056  bf00              NOP      
                  |L5.88|
000058  f8d5b000          LDR      r11,[r5,#0]
00005c  6028              STR      r0,[r5,#0]
00005e  4628              MOV      r0,r5
000060  ea5f050b          MOVS     r5,r11
000064  d1f8              BNE      |L5.88|
                  |L5.102|
;;;146    		list=core_list_reverse(list);
000066  4605              MOV      r5,r0
;;;147    		if (this_find==NULL) {
000068  2c00              CMP      r4,#0
00006a  d049              BEQ      |L5.256|
;;;148    			missed++;
;;;149    			retval+=(list->next->info->data16 >> 8) & 1;
;;;150    		}
;;;151    		else {
;;;152    			found++;
00006c  f1080001          ADD      r0,r8,#1
000070  fa1ff880          UXTH     r8,r0
;;;153    			if (this_find->info->data16 & 0x1) /* use found value */
000074  6860              LDR      r0,[r4,#4]
000076  f9b00000          LDRSH    r0,[r0,#0]
00007a  f0100f01          TST      r0,#1
00007e  d003              BEQ      |L5.136|
;;;154    				retval+=(this_find->info->data16 >> 9) & 1;
000080  f3c02040          UBFX     r0,r0,#9,#1
000084  4418              ADD      r0,r0,r3
000086  b283              UXTH     r3,r0
                  |L5.136|
;;;155    			/* and cache next item at the head of the list (if any) */
;;;156    			if (this_find->next != NULL) {
000088  6820              LDR      r0,[r4,#0]
00008a  b130              CBZ      r0,|L5.154|
;;;157    				finder = this_find->next;
;;;158    				this_find->next = finder->next;
00008c  f8d0b000          LDR      r11,[r0,#0]
;;;159    				finder->next=list->next;
000090  f8c4b000          STR      r11,[r4,#0]
000094  682c              LDR      r4,[r5,#0]
;;;160    				list->next=finder;
000096  6004              STR      r4,[r0,#0]
000098  6028              STR      r0,[r5,#0]
                  |L5.154|
;;;161    			}
;;;162    		}
;;;163    		if (info.idx>=0)
00009a  2900              CMP      r1,#0
;;;164    			info.idx++;
00009c  bfa4              ITT      GE
00009e  1c48              ADDGE    r0,r1,#1
0000a0  f360461f          BFIGE    r6,r0,#16,#16
0000a4  f10c0001          ADD      r0,r12,#1             ;143
0000a8  fa0ffc80          SXTH     r12,r0                ;143
0000ac  45d4              CMP      r12,r10               ;143
0000ae  dbb7              BLT      |L5.32|
                  |L5.176|
;;;165    #if CORE_DEBUG
;;;166    	ee_printf("List find %d: [%d,%d,%d]\n",i,retval,missed,found);
;;;167    #endif
;;;168    	}
;;;169    	retval+=found*4-missed;
0000b0  ebc70088          RSB      r0,r7,r8,LSL #2
0000b4  4418              ADD      r0,r0,r3
0000b6  b287              UXTH     r7,r0
;;;170    	/* sort the list by data content and remove one item*/
;;;171    	if (finder_idx>0)
0000b8  f1b90f00          CMP      r9,#0
0000bc  dd04              BLE      |L5.200|
;;;172    		list=core_list_mergesort(list,cmp_complex,res);
0000be  4930              LDR      r1,|L5.384|
0000c0  4628              MOV      r0,r5
0000c2  f7fffffe          BL       core_list_mergesort
0000c6  4605              MOV      r5,r0
                  |L5.200|
;;;173    	remover=core_list_remove(list->next);
0000c8  6828              LDR      r0,[r5,#0]
0000ca  e9d08100          LDRD     r8,r1,[r0,#0]
0000ce  f8d82004          LDR      r2,[r8,#4]
0000d2  6042              STR      r2,[r0,#4]
0000d4  f8c81004          STR      r1,[r8,#4]
0000d8  6801              LDR      r1,[r0,#0]
0000da  6809              LDR      r1,[r1,#0]
0000dc  6001              STR      r1,[r0,#0]
0000de  2000              MOVS     r0,#0
;;;174    	/* CRC data content of list from location of index N forward, and then undo remove */
;;;175    	finder=core_list_find(list,&info);
0000e0  f8c80000          STR      r0,[r8,#0]
0000e4  4628              MOV      r0,r5
0000e6  1431              ASRS     r1,r6,#16
0000e8  bf48              IT       MI
0000ea  b231              SXTHMI   r1,r6
0000ec  d412              BMI      |L5.276|
                  |L5.238|
0000ee  b1d0              CBZ      r0,|L5.294|
0000f0  6842              LDR      r2,[r0,#4]
0000f2  f9b22002          LDRSH    r2,[r2,#2]
0000f6  428a              CMP      r2,r1
0000f8  bf18              IT       NE
0000fa  6800              LDRNE    r0,[r0,#0]
0000fc  d1f7              BNE      |L5.238|
0000fe  e010              B        |L5.290|
                  |L5.256|
000100  1c78              ADDS     r0,r7,#1              ;148
000102  b287              UXTH     r7,r0                 ;148
000104  6828              LDR      r0,[r5,#0]            ;149
000106  6840              LDR      r0,[r0,#4]            ;149
000108  8800              LDRH     r0,[r0,#0]            ;149
00010a  f3c02000          UBFX     r0,r0,#8,#1           ;149
00010e  4418              ADD      r0,r0,r3              ;149
000110  b283              UXTH     r3,r0                 ;149
000112  e7c2              B        |L5.154|
                  |L5.276|
000114  b138              CBZ      r0,|L5.294|
000116  6842              LDR      r2,[r0,#4]            ;149
000118  7812              LDRB     r2,[r2,#0]            ;149
00011a  428a              CMP      r2,r1                 ;149
00011c  bf18              IT       NE                    ;149
00011e  6800              LDRNE    r0,[r0,#0]            ;149
000120  d1f8              BNE      |L5.276|
                  |L5.290|
000122  4604              MOV      r4,r0
;;;176    	if (!finder)
000124  e001              B        |L5.298|
                  |L5.294|
;;;177    		finder=list->next;
000126  682c              LDR      r4,[r5,#0]
000128  b14c              CBZ      r4,|L5.318|
                  |L5.298|
;;;178    	while (finder) {
;;;179    		retval=crc16(list->info->data16,retval);
00012a  6868              LDR      r0,[r5,#4]
00012c  4639              MOV      r1,r7
00012e  f9b00000          LDRSH    r0,[r0,#0]
000132  f7fffffe          BL       crc16
;;;180    		finder=finder->next;
000136  6824              LDR      r4,[r4,#0]
000138  4607              MOV      r7,r0                 ;179
00013a  2c00              CMP      r4,#0                 ;178
00013c  d1f5              BNE      |L5.298|
                  |L5.318|
00013e  6828              LDR      r0,[r5,#0]            ;178
000140  f8d81004          LDR      r1,[r8,#4]            ;178
000144  6842              LDR      r2,[r0,#4]            ;178
000146  f8c82004          STR      r2,[r8,#4]            ;178
00014a  6041              STR      r1,[r0,#4]            ;178
00014c  6801              LDR      r1,[r0,#0]            ;178
00014e  f8c81000          STR      r1,[r8,#0]            ;178
;;;181    	}
;;;182    #if CORE_DEBUG
;;;183    	ee_printf("List sort 1: %04x\n",retval);
;;;184    #endif
;;;185    	remover=core_list_undo_remove(remover,list->next);
;;;186    	/* sort the list by index, in effect returning the list to original state */
;;;187    	list=core_list_mergesort(list,cmp_idx,NULL);
000152  f8c08000          STR      r8,[r0,#0]
000156  2200              MOVS     r2,#0
000158  490a              LDR      r1,|L5.388|
00015a  4628              MOV      r0,r5
00015c  f7fffffe          BL       core_list_mergesort
;;;188    	/* CRC data content of list */
;;;189    	finder=list->next;
;;;190    	while (finder) {
000160  6804              LDR      r4,[r0,#0]
000162  4605              MOV      r5,r0                 ;187
000164  b14c              CBZ      r4,|L5.378|
                  |L5.358|
;;;191    		retval=crc16(list->info->data16,retval);
000166  6868              LDR      r0,[r5,#4]
000168  4639              MOV      r1,r7
00016a  f9b00000          LDRSH    r0,[r0,#0]
00016e  f7fffffe          BL       crc16
;;;192    		finder=finder->next;
000172  6824              LDR      r4,[r4,#0]
000174  4607              MOV      r7,r0                 ;191
000176  2c00              CMP      r4,#0                 ;190
000178  d1f5              BNE      |L5.358|
                  |L5.378|
;;;193    	}
;;;194    #if CORE_DEBUG
;;;195    	ee_printf("List sort 2: %04x\n",retval);
;;;196    #endif
;;;197    	return retval;
00017a  4638              MOV      r0,r7
;;;198    }
00017c  e8bd9ff0          POP      {r4-r12,pc}
;;;199    /* Function: core_list_init
                          ENDP

                  |L5.384|
                          DCD      cmp_complex
                  |L5.388|
                          DCD      cmp_idx

                          AREA ||i.core_list_find||, CODE, READONLY, ALIGN=1

                  core_list_find PROC
;;;368    */
;;;369    list_head *core_list_find(list_head *list,list_data *info) {
000000  f9b12002          LDRSH    r2,[r1,#2]
;;;370    	if (info->idx>=0) {
000004  2a00              CMP      r2,#0
000006  db0a              BLT      |L6.30|
                  |L6.8|
;;;371    		while (list && (list->info->idx != info->idx))
000008  2800              CMP      r0,#0
;;;372    			list=list->next;
;;;373    		return list;
;;;374    	} else {
;;;375    		while (list && ((list->info->data16 & 0xff) != info->data16))
;;;376    			list=list->next;
;;;377    		return list;
;;;378    	}
;;;379    }
00000a  bf08              IT       EQ
00000c  4770              BXEQ     lr
00000e  6841              LDR      r1,[r0,#4]            ;371
000010  f9b11002          LDRSH    r1,[r1,#2]            ;371
000014  4291              CMP      r1,r2                 ;371
000016  bf18              IT       NE                    ;372
000018  6800              LDRNE    r0,[r0,#0]            ;372
00001a  d1f5              BNE      |L6.8|
00001c  4770              BX       lr
                  |L6.30|
00001e  2800              CMP      r0,#0                 ;375
000020  bf08              IT       EQ
000022  4770              BXEQ     lr
000024  6842              LDR      r2,[r0,#4]            ;375
000026  f9b13000          LDRSH    r3,[r1,#0]            ;375
00002a  7812              LDRB     r2,[r2,#0]            ;375
00002c  429a              CMP      r2,r3                 ;375
00002e  bf18              IT       NE                    ;376
000030  6800              LDRNE    r0,[r0,#0]            ;376
000032  d1f4              BNE      |L6.30|
000034  4770              BX       lr
;;;380    /* Function: core_list_reverse
                          ENDP


                          AREA ||i.core_list_init||, CODE, READONLY, ALIGN=2

                  core_list_init PROC
;;;211    */
;;;212    list_head *core_list_init(ee_u32 blksize, list_head *memblock, ee_s16 seed) {
000000  e92d0ff0          PUSH     {r4-r11}
;;;213    	/* calculated pointers for the list */
;;;214    	ee_u32 per_item=16+sizeof(struct list_data_s);
000004  2314              MOVS     r3,#0x14
;;;215    	ee_u32 size=(blksize/per_item)-2; /* to accomodate systems with 64b pointers, and make sure same code is executed, set max list elements */
000006  fbb0f0f3          UDIV     r0,r0,r3
00000a  1e87              SUBS     r7,r0,#2
;;;216    	list_head *memblock_end=memblock+size;
00000c  eb0104c7          ADD      r4,r1,r7,LSL #3
;;;217    	list_data *datablock=(list_data *)(memblock_end);
;;;218    	list_data *datablock_end=datablock+size;
;;;219    	/* some useful variables */
;;;220    	ee_u32 i;
;;;221    	list_head *finder,*list=memblock;
;;;222    	list_data info;
;;;223    
;;;224    	/* create a fake items for the list head and tail */
;;;225    	list->next=NULL;
000010  2300              MOVS     r3,#0
;;;226    	list->info=datablock;
;;;227    	list->info->idx=0x0000;
000012  604c              STR      r4,[r1,#4]
000014  600b              STR      r3,[r1,#0]
000016  8063              STRH     r3,[r4,#2]
;;;228    	list->info->data16=(ee_s16)0x8080;
000018  f8d1c004          LDR      r12,[r1,#4]
00001c  f2480380          MOV      r3,#0x8080
000020  4608              MOV      r0,r1                 ;221
000022  f8ac3000          STRH     r3,[r12,#0]
;;;229    	memblock++;
000026  f1010c08          ADD      r12,r1,#8
;;;230    	datablock++;
00002a  1d23              ADDS     r3,r4,#4
00002c  3110              ADDS     r1,r1,#0x10
00002e  eb040587          ADD      r5,r4,r7,LSL #2       ;218
;;;231    	info.idx=0x7fff;
000032  f64779ff          MOV      r9,#0x7fff
;;;232    	info.data16=(ee_s16)0xffff;
000036  f04f36ff          MOV      r6,#0xffffffff
00003a  42a1              CMP      r1,r4
00003c  bf3c              ITT      CC
00003e  f1030804          ADDCC    r8,r3,#4
000042  45a8              CMPCC    r8,r5
000044  d20d              BCS      |L7.98|
000046  4661              MOV      r1,r12                ;212
000048  f8d08000          LDR      r8,[r0,#0]            ;212
00004c  f8c18000          STR      r8,[r1,#0]            ;212
000050  6001              STR      r1,[r0,#0]            ;212
000052  604b              STR      r3,[r1,#4]            ;212
000054  4619              MOV      r1,r3                 ;212
000056  f10c0c08          ADD      r12,r12,#8            ;212
00005a  800e              STRH     r6,[r1,#0]            ;212
00005c  1d1b              ADDS     r3,r3,#4              ;212
00005e  f8a19002          STRH     r9,[r1,#2]            ;212
                  |L7.98|
;;;233    	core_list_insert_new(list,&info,&memblock,&datablock,memblock_end,datablock_end);
;;;234    	
;;;235    	/* then insert size items */
;;;236    	for (i=0; i<size; i++) {
000062  2100              MOVS     r1,#0
000064  2f00              CMP      r7,#0
000066  d922              BLS      |L7.174|
                  |L7.104|
;;;237    		ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
000068  ea820601          EOR      r6,r2,r1
00006c  f006080f          AND      r8,r6,#0xf
000070  460e              MOV      r6,r1
;;;238    		ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
000072  f36806df          BFI      r6,r8,#3,#29
;;;239    		info.data16=(dat<<8) | dat;		/* fill the data with actual data and upper bits with rebuild value */
000076  ea462a06          ORR      r10,r6,r6,LSL #8
00007a  f10c0608          ADD      r6,r12,#8
00007e  42a6              CMP      r6,r4
000080  bf3c              ITT      CC
000082  f1030804          ADDCC    r8,r3,#4
000086  45a8              CMPCC    r8,r5
000088  d20e              BCS      |L7.168|
00008a  46e0              MOV      r8,r12
00008c  6806              LDR      r6,[r0,#0]
00008e  f8c86000          STR      r6,[r8,#0]
000092  f8c08000          STR      r8,[r0,#0]
000096  f8c83004          STR      r3,[r8,#4]
00009a  f8a3a000          STRH     r10,[r3,#0]
00009e  f8a39002          STRH     r9,[r3,#2]
0000a2  f10c0c08          ADD      r12,r12,#8
0000a6  1d1b              ADDS     r3,r3,#4
                  |L7.168|
0000a8  1c49              ADDS     r1,r1,#1
0000aa  42b9              CMP      r1,r7                 ;236
0000ac  d3dc              BCC      |L7.104|
                  |L7.174|
;;;240    		core_list_insert_new(list,&info,&memblock,&datablock,memblock_end,datablock_end);
;;;241    	}
;;;242    	/* and now index the list so we know initial seed order of the list */
;;;243    	finder=list->next;
;;;244    	i=1;
;;;245    	while (finder->next!=NULL) {
0000ae  6803              LDR      r3,[r0,#0]
0000b0  2101              MOVS     r1,#1                 ;244
0000b2  f8d3c000          LDR      r12,[r3,#0]
0000b6  f1bc0f00          CMP      r12,#0
0000ba  d01f              BEQ      |L7.252|
;;;246    		if (i<size/5) /* first 20% of the list in order */
0000bc  f8dfc048          LDR      r12,|L7.264|
0000c0  fbac4c07          UMULL    r4,r12,r12,r7
0000c4  ea4f049c          LSR      r4,r12,#2
                  |L7.200|
0000c8  428c              CMP      r4,r1
0000ca  d905              BLS      |L7.216|
;;;247    			finder->info->idx=i++;
0000cc  f8d3c004          LDR      r12,[r3,#4]
0000d0  f8ac1002          STRH     r1,[r12,#2]
0000d4  1c49              ADDS     r1,r1,#1
0000d6  e00b              B        |L7.240|
                  |L7.216|
;;;248    		else { 
;;;249    			ee_u16 pat=(ee_u16)(i++ ^ seed); /* get a pseudo random number */
0000d8  ea810c02          EOR      r12,r1,r2
0000dc  1c49              ADDS     r1,r1,#1
;;;250    			finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
0000de  f0010507          AND      r5,r1,#7
0000e2  ea4c2c05          ORR      r12,r12,r5,LSL #8
0000e6  685d              LDR      r5,[r3,#4]
0000e8  f3cc0c0d          UBFX     r12,r12,#0,#14
0000ec  f8a5c002          STRH     r12,[r5,#2]
                  |L7.240|
;;;251    		}
;;;252    		finder=finder->next;
0000f0  681b              LDR      r3,[r3,#0]
0000f2  f8d3c000          LDR      r12,[r3,#0]           ;245
0000f6  f1bc0f00          CMP      r12,#0                ;245
0000fa  d1e5              BNE      |L7.200|
                  |L7.252|
;;;253    	}
;;;254    	list = core_list_mergesort(list,cmp_idx,NULL);
0000fc  e8bd0ff0          POP      {r4-r11}
000100  2200              MOVS     r2,#0
000102  4902              LDR      r1,|L7.268|
000104  f7ffbffe          B.W      core_list_mergesort
;;;255    #if CORE_DEBUG
;;;256    	ee_printf("Initialized list:\n");
;;;257    	finder=list;
;;;258    	while (finder) {
;;;259    		ee_printf("[%04x,%04x]",finder->info->idx,(ee_u16)finder->info->data16);
;;;260    		finder=finder->next;
;;;261    	}
;;;262    	ee_printf("\n");
;;;263    #endif
;;;264    	return list;
;;;265    }
;;;266    
                          ENDP

                  |L7.264|
                          DCD      0xcccccccd
                  |L7.268|
                          DCD      cmp_idx

                          AREA ||i.core_list_insert_new||, CODE, READONLY, ALIGN=1

                  core_list_insert_new PROC
;;;280    */
;;;281    list_head *core_list_insert_new(list_head *insert_point, list_data *info, list_head **memblock, list_data **datablock
000000  b470              PUSH     {r4-r6}
;;;282    	, list_head *memblock_end, list_data *datablock_end) {
000002  4684              MOV      r12,r0
000004  e9dd6503          LDRD     r6,r5,[sp,#0xc]
;;;283    	list_head *newitem;
;;;284    	
;;;285    	if ((*memblock+1) >= memblock_end)
000008  6810              LDR      r0,[r2,#0]
00000a  f1000408          ADD      r4,r0,#8
00000e  42b4              CMP      r4,r6
000010  d203              BCS      |L8.26|
;;;286    		return NULL;
;;;287    	if ((*datablock+1) >= datablock_end)
000012  681e              LDR      r6,[r3,#0]
000014  1d36              ADDS     r6,r6,#4
000016  42ae              CMP      r6,r5
000018  d302              BCC      |L8.32|
                  |L8.26|
;;;288    		return NULL;
;;;289    		
;;;290    	newitem=*memblock;
;;;291    	(*memblock)++;
;;;292    	newitem->next=insert_point->next;
;;;293    	insert_point->next=newitem;
;;;294    	
;;;295    	newitem->info=*datablock;
;;;296    	(*datablock)++;
;;;297    	copy_info(newitem->info,info);
;;;298    	
;;;299    	return newitem;
;;;300    }
00001a  bc70              POP      {r4-r6}
00001c  2000              MOVS     r0,#0                 ;288
00001e  4770              BX       lr
                  |L8.32|
000020  6014              STR      r4,[r2,#0]            ;292
000022  f8dc2000          LDR      r2,[r12,#0]           ;292
000026  6002              STR      r2,[r0,#0]            ;293
000028  f8cc0000          STR      r0,[r12,#0]           ;295
00002c  681a              LDR      r2,[r3,#0]            ;295
00002e  6042              STR      r2,[r0,#4]            ;296
000030  681a              LDR      r2,[r3,#0]            ;296
000032  1d12              ADDS     r2,r2,#4              ;296
000034  601a              STR      r2,[r3,#0]            ;297
000036  6842              LDR      r2,[r0,#4]            ;297
000038  880b              LDRH     r3,[r1,#0]            ;297
00003a  8013              STRH     r3,[r2,#0]            ;297
00003c  8849              LDRH     r1,[r1,#2]            ;297
00003e  8051              STRH     r1,[r2,#2]            ;297
000040  bc70              POP      {r4-r6}
000042  4770              BX       lr
;;;301    
                          ENDP


                          AREA ||i.core_list_mergesort||, CODE, READONLY, ALIGN=2

                  core_list_mergesort PROC
;;;424     */
;;;425    list_head *core_list_mergesort(list_head *list, list_cmp cmp, core_results *res) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  4682              MOV      r10,r0
;;;426        list_head *p, *q, *e, *tail;
;;;427        ee_s32 insize, nmerges, psize, qsize, i;
;;;428    
;;;429        insize = 1;
000006  f04f0901          MOV      r9,#1
;;;430    
;;;431        while (1) {
;;;432            p = list;
00000a  bf00              NOP      
                  |L9.12|
00000c  ea5f050a          MOVS     r5,r10
;;;433            list = NULL;
000010  f04f0a00          MOV      r10,#0
;;;434            tail = NULL;
000014  4657              MOV      r7,r10
;;;435    
;;;436            nmerges = 0;  /* count number of merges we do in this pass */
000016  46d3              MOV      r11,r10
;;;437    
;;;438            while (p) {
000018  d03f              BEQ      |L9.154|
                  |L9.26|
;;;439                nmerges++;  /* there exists a merge to be done */
;;;440                /* step `insize' places along from p */
;;;441                q = p;
;;;442                psize = 0;
00001a  2600              MOVS     r6,#0
00001c  462c              MOV      r4,r5                 ;441
;;;443                for (i = 0; i < insize; i++) {
00001e  4630              MOV      r0,r6
000020  f10b0b01          ADD      r11,r11,#1
000024  f1b90f00          CMP      r9,#0
;;;444                    psize++;
;;;445    			    q = q->next;
;;;446                    if (!q) break;
;;;447                }
;;;448    
;;;449                /* if q hasn't fallen off end, we have two lists to merge */
;;;450                qsize = insize;
000028  bfd8              IT       LE
00002a  46c8              MOVLE    r8,r9
00002c  dd24              BLE      |L9.120|
                  |L9.46|
00002e  6824              LDR      r4,[r4,#0]            ;445
000030  1c76              ADDS     r6,r6,#1              ;445
000032  2c00              CMP      r4,#0                 ;446
000034  bf1c              ITT      NE                    ;446
000036  1c40              ADDNE    r0,r0,#1              ;446
000038  4548              CMPNE    r0,r9                 ;443
00003a  dbf8              BLT      |L9.46|
00003c  46c8              MOV      r8,r9
                  |L9.62|
;;;451    
;;;452                /* now we have two lists; merge them */
;;;453                while (psize > 0 || (qsize > 0 && q)) {
00003e  2e00              CMP      r6,#0
000040  dd1a              BLE      |L9.120|
                  |L9.66|
;;;454    
;;;455    				/* decide whether next element of merge comes from p or q */
;;;456    				if (psize == 0) {
000042  b17e              CBZ      r6,|L9.100|
;;;457    				    /* p is empty; e must come from q. */
;;;458    				    e = q; q = q->next; qsize--;
;;;459    				} else if (qsize == 0 || !q) {
000044  f1b80f00          CMP      r8,#0
000048  bf18              IT       NE
00004a  2c00              CMPNE    r4,#0
00004c  d006              BEQ      |L9.92|
;;;460    				    /* q is empty; e must come from p. */
;;;461    				    e = p; p = p->next; psize--;
;;;462    				} else if (cmp(p->info,q->info,res) <= 0) {
00004e  e9dd3201          LDRD     r3,r2,[sp,#4]
000052  6861              LDR      r1,[r4,#4]
000054  6868              LDR      r0,[r5,#4]
000056  4798              BLX      r3
000058  2800              CMP      r0,#0
00005a  dc03              BGT      |L9.100|
                  |L9.92|
;;;463    				    /* First element of p is lower (or same); e must come from p. */
;;;464    				    e = p; p = p->next; psize--;
00005c  4628              MOV      r0,r5
00005e  682d              LDR      r5,[r5,#0]
000060  1e76              SUBS     r6,r6,#1
000062  e003              B        |L9.108|
                  |L9.100|
;;;465    				} else {
;;;466    				    /* First element of q is lower; e must come from q. */
;;;467    				    e = q; q = q->next; qsize--;
000064  4620              MOV      r0,r4
000066  6824              LDR      r4,[r4,#0]
000068  f1a80801          SUB      r8,r8,#1
                  |L9.108|
;;;468    				}
;;;469    
;;;470    		        /* add the next element to the merged list */
;;;471    				if (tail) {
00006c  2f00              CMP      r7,#0
;;;472    				    tail->next = e;
00006e  bf14              ITE      NE
000070  6038              STRNE    r0,[r7,#0]
;;;473    				} else {
;;;474    				    list = e;
000072  4682              MOVEQ    r10,r0
;;;475    				}
;;;476    				tail = e;
000074  4607              MOV      r7,r0
000076  e7e2              B        |L9.62|
                  |L9.120|
000078  f1b80f00          CMP      r8,#0                 ;453
00007c  dd02              BLE      |L9.132|
00007e  2c00              CMP      r4,#0                 ;453
000080  d1df              BNE      |L9.66|
000082  e001              B        |L9.136|
                  |L9.132|
;;;477    	        }
;;;478    
;;;479    			/* now p has stepped `insize' places along, and q has too */
;;;480    			p = q;
000084  0025              MOVS     r5,r4
000086  d1c8              BNE      |L9.26|
                  |L9.136|
;;;481            }
;;;482    		
;;;483    	    tail->next = NULL;
000088  2000              MOVS     r0,#0
;;;484    
;;;485            /* If we have done only one merge, we're finished. */
;;;486            if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
00008a  6038              STR      r0,[r7,#0]
00008c  f1bb0f01          CMP      r11,#1
;;;487                return list;
;;;488    
;;;489            /* Otherwise repeat, merging lists twice the size */
;;;490            insize *= 2;
000090  bfc8              IT       GT
000092  ea4f0949          LSLGT    r9,r9,#1
000096  dcb9              BGT      |L9.12|
000098  e001              B        |L9.158|
                  |L9.154|
00009a  2000              MOVS     r0,#0                 ;483
00009c  6000              STR      r0,[r0,#0]            ;483
                  |L9.158|
;;;491        }
;;;492    #if COMPILER_REQUIRES_SORT_RETURN
;;;493    	return list;
;;;494    #endif
;;;495    }
00009e  b003              ADD      sp,sp,#0xc
0000a0  4650              MOV      r0,r10                ;487
0000a2  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP


                          AREA ||i.core_list_remove||, CODE, READONLY, ALIGN=1

                  core_list_remove PROC
;;;314    */
;;;315    list_head *core_list_remove(list_head *item) {
000000  e9d01200          LDRD     r1,r2,[r0,#0]
;;;316    	list_data *tmp;
;;;317    	list_head *ret=item->next;
;;;318    	/* swap data pointers */
;;;319    	tmp=item->info;
;;;320    	item->info=ret->info;
000004  684b              LDR      r3,[r1,#4]
;;;321    	ret->info=tmp;
000006  6043              STR      r3,[r0,#4]
;;;322    	/* and eliminate item */
;;;323    	item->next=item->next->next;
000008  604a              STR      r2,[r1,#4]
00000a  6802              LDR      r2,[r0,#0]
00000c  6812              LDR      r2,[r2,#0]
;;;324    	ret->next=NULL;
00000e  6002              STR      r2,[r0,#0]
000010  2000              MOVS     r0,#0
;;;325    	return ret;
000012  6008              STR      r0,[r1,#0]
000014  4608              MOV      r0,r1
;;;326    }
000016  4770              BX       lr
;;;327    
                          ENDP


                          AREA ||i.core_list_reverse||, CODE, READONLY, ALIGN=1

                  core_list_reverse PROC
;;;393    
;;;394    list_head *core_list_reverse(list_head *list) {
000000  2100              MOVS     r1,#0
000002  b120              CBZ      r0,|L11.14|
                  |L11.4|
;;;395    	list_head *next=NULL, *tmp;
;;;396    	while (list) {
;;;397    		tmp=list->next;
;;;398    		list->next=next;
000004  6802              LDR      r2,[r0,#0]
;;;399    		next=list;
000006  6001              STR      r1,[r0,#0]
000008  4601              MOV      r1,r0
;;;400    		list=tmp;
00000a  0010              MOVS     r0,r2
00000c  d1fa              BNE      |L11.4|
                  |L11.14|
;;;401    	}
;;;402    	return next;
00000e  4608              MOV      r0,r1
;;;403    }
000010  4770              BX       lr
;;;404    /* Function: core_list_mergesort
                          ENDP


                          AREA ||i.core_list_undo_remove||, CODE, READONLY, ALIGN=1

                  core_list_undo_remove PROC
;;;343    */
;;;344    list_head *core_list_undo_remove(list_head *item_removed, list_head *item_modified) {
000000  6842              LDR      r2,[r0,#4]
;;;345    	list_data *tmp;
;;;346    	/* swap data pointers */
;;;347    	tmp=item_removed->info;
;;;348    	item_removed->info=item_modified->info;
000002  684b              LDR      r3,[r1,#4]
;;;349    	item_modified->info=tmp;
000004  6043              STR      r3,[r0,#4]
;;;350    	/* and insert item */
;;;351    	item_removed->next=item_modified->next;
000006  604a              STR      r2,[r1,#4]
000008  680a              LDR      r2,[r1,#0]
;;;352    	item_modified->next=item_removed;
00000a  6002              STR      r2,[r0,#0]
00000c  6008              STR      r0,[r1,#0]
;;;353    	return item_removed;
;;;354    }
00000e  4770              BX       lr
;;;355    
                          ENDP

